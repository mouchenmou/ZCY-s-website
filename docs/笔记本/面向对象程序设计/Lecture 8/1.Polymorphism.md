上节课中我们通过以下代码实现了调用`Employee`的`print`函数来打印`pete`：
```c++
    Manager pete("Pete", "444-55-6666", "Bakery");
    Employee *ep = &pete; //upcast
    ep->print(cout);
```
如果说我们执行`ep->print(cout)`但是又不想用`Employee`的`print`函数，也就用pete实际的类型（`Manager`）而非被指代的类型（`Employee`）的print函数，就需要用到`Polymorphism`（多态）。

但是问题来了，我们明明将`ep`定义为了`Employee`类型，为什么还要调用`Manager`的`print`呢？既然这样为什么不执行`Manger *ep = &pete;`然后直接调用`Manager`的`print`呢？下面用一个drawing program来解释一下

---
## A drawing program
![](附件/Pasted%20image%2020251120171531.png)
!!! example "虚函数的意义"
    Circle、Rectangle、Ellipse全都继承自shape这个父类。shape会有一些公用的行为，图中的render（绘制）、move（移动）、resize（改变尺寸）都是它的公用行为。但是在定义shape这个父类的时候，没办法在这个类里面定义render函数（因为有这么多个类型的图形，我也不知道画哪一个）。
    
    这个时候只能构造所谓的 **虚函数** ，就是说`render`只是一个接口，只要是一个shape那就会有`render`这个函数，但是具体怎么实现就交给子类来定义。比如说circle这个子类就将render定义成画圆形的函数。
    
    定义好所有的子类形状之后，将所有的形状都up-casting成shape。这样之后，我的系统或者外部类类中就不需要知道它们具体是什么形状，只要调用render，就能各自object真实的类型对应的render的结果。

!!! conception "Inheritance in C++"
    ![](附件/Pasted%20image%2020251120174019.png)

!!! conception "Conceptual model"
    ![](附件/Pasted%20image%2020251120174519.png)
    
    - center()和move()可以直接定义在父类中，因为move()只是改变坐标，每个图形都一样，center()同理。
    - render()必须定义在子类中，上面已经讲过原因了。
    

---

