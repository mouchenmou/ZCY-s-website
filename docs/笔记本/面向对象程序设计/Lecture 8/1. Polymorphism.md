上节课中我们通过以下代码实现了调用`Employee`的`print`函数来打印`pete`：
```c++
    Manager pete("Pete", "444-55-6666", "Bakery");
    Employee *ep = &pete; //upcast
    ep->print(cout);
```
如果说我们执行`ep->print(cout)`但是又不想用`Employee`的`print`函数，也就用pete实际的类型（`Manager`）而非被指代的类型（`Employee`）的print函数，就需要用到`Polymorphism`（多态）。

但是问题来了，我们明明将`ep`定义为了`Employee`类型，为什么还要调用`Manager`的`print`呢？既然这样为什么不执行`Manger *ep = &pete;`然后直接调用`Manager`的`print`呢？下面用一个drawing program来解释一下

---
## A drawing program
![](附件/Pasted%20image%2020251120171531.png)
!!! example "虚函数的意义"
    Circle、Rectangle、Ellipse全都继承自shape这个父类。shape会有一些公用的行为，图中的render（绘制）、move（移动）、resize（改变尺寸）都是它的公用行为。但是在定义shape这个父类的时候，没办法在这个类里面定义render函数（因为有这么多个类型的图形，我也不知道画哪一个）。
    
    这个时候只能构造所谓的 **虚函数** ，就是说`render`只是一个接口，只要是一个shape那就会有`render`这个函数，但是具体怎么实现就交给子类来定义。比如说circle这个子类就将render定义成画圆形的函数。
    
    定义好所有的子类形状之后，将所有的形状都up-casting成shape。这样之后，我的系统或者外部类类中就不需要知道它们具体是什么形状，只要调用render，就能各自object真实的类型对应的render的结果。

!!! conception "Inheritance in C++"
    ![](附件/Pasted%20image%2020251120174019.png)

!!! conception "Conceptual model"
    ![](附件/Pasted%20image%2020251120174519.png)
    
    - center()和move()可以直接定义在父类中，因为move()只是改变坐标，每个图形都一样，center()同理。
    - render()必须定义在子类中，上面已经讲过原因了。

!!! conception "Shape"
    ```c++
        class Point { ... }; // (x, y) point
        class Shape {
        public:
            Shape(); // 构造函数
            void move(const Point&); //&避免了二次开辟内存
            
            virtual void render();
            irtual void resize();
            virtual ~Shape(); // 虚析构函数
    
        protected:
            Point center; 
        };
    ```
    !!! warning "Question: 为什么Shape的析构函数也是虚函数
        ```c++
            Shape* s_ptr = new Circle(5.0f); // 基类指针指向派生类对象
        ``` 
        我们执行了上述代码之后，如果Shape的析构函数不是虚函数，那么在解构~s_ptr时调用的就不是Circle的析构函数而是Shape的析构函数，然而Circle中定义了一些Shape中没有的东西，因此如果调用Shape的析构函数会导致内存释放不干净。

!!! conception "Add new shape"
    ```c++
        class Ellipse: public Shape{ 
        public: 
            Ellipse(float major, float minor); 
            virtual void render(); // will define own 
        protected: 
            float major_axis, minor_axis;
        }; 
        class Circle: public Ellipse { 
        public: 
             Circle(float radius) : Ellipse(radius, radius) {} 
             virtual void render();
         };
    ```
    ### 注意：
    - 一旦在基类 (`Shape`) 中将一个函数 (`render()`) 声明为 `virtual`，那么在所有继承链上的派生类中，这个函数就**自动**、**永久地**保持 `virtual` 属性。
    - 这意味着，即使你在 `Ellipse` 或 `Circle` 中省略 `virtual` 关键字，它仍然是一个虚函数，并且可以被更深层次的派生类（比如 `class HalfCircle : public Circle`）继续重写。
    - 即使在Circle或者Ellipse的.cpp文件中定义了`render`这个虚函数，它仍然是虚函数。


---

