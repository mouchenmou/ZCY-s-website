上节课中我们通过以下代码实现了调用`Employee`的`print`函数来打印`pete`：
```c++
    Manager pete("Pete", "444-55-6666", "Bakery");
    Employee *ep = &pete; //upcast
    ep->print(cout);
```
如果说我们执行`ep->print(cout)`但是又不想用`Employee`的`print`函数，也就用pete实际的类型（`Manager`）而非被指代的类型（`Employee`）的print函数，就需要用到`Polymorphism`（多态）。

但是问题来了，我们明明将`ep`定义为了`Employee`类型，为什么还要调用`Manager`的`print`呢？既然这样为什么不执行`Manger *ep = &pete;`然后直接调用`Manager`的`print`呢？下面用一个drawing program来解释一下

---
## A drawing program
![](附件/Pasted%20image%2020251120171531.png)
!!! example "虚函数的意义"
    Circle、Rectangle、Ellipse全都继承自shape这个父类。shape会有一些公用的行为，图中的render（绘制）、move（移动）、resize（改变尺寸）都是它的公用行为。但是在定义shape这个父类的时候，没办法在这个类里面定义render函数（因为有这么多个类型的图形，我也不知道画哪一个）。
    
    这个时候只能构造所谓的 **虚函数** ，就是说`render`只是一个接口，只要是一个shape那就会有`render`这个函数，但是具体怎么实现就交给子类来定义。比如说circle这个子类就将render定义成画圆形的函数。
    
    定义好所有的子类形状之后，将所有的形状都up-casting成shape。这样之后，我的系统或者外部类中就不需要知道它们具体是什么形状，只要调用render，就能各自object真实的类型对应的render的结果。

!!! conception "Inheritance in C++"
    ![](附件/Pasted%20image%2020251120174019.png)

!!! conception "Conceptual model"
    ![](附件/Pasted%20image%2020251120174519.png)
    
    - center()和move()可以直接定义在父类中，因为move()只是改变坐标，每个图形都一样，center()同理。
    - render()必须定义在子类中，上面已经讲过原因了。

!!! conception "Shape"
    ```c++
        class Point { ... }; // (x, y) point
        class Shape {
        public:
            Shape(); // 构造函数
            void move(const Point&); //&避免了二次开辟内存
            
            virtual void render();
            irtual void resize();
            virtual ~Shape(); // 虚析构函数
    
        protected:
            Point center; 
        };
    ```
    
    !!! warning "Question: 为什么Shape的析构函数也是虚函数"
        ```c++
            Shape* s_ptr = new Circle(5.0f); // 基类指针指向派生类对象
        ``` 
        我们执行了上述代码之后，如果Shape的析构函数不是虚函数，那么在解构~s_ptr时调用的就不是Circle的析构函数而是Shape的析构函数，然而Circle中定义了一些Shape中没有的东西，因此如果调用Shape的析构函数会导致内存释放不干净。

!!! conception "Add new shape"
    ```c++
        class Ellipse: public Shape{ 
        public: 
            Ellipse(float major, float minor); 
            virtual void render(); // will define own 
        protected: 
            float major_axis, minor_axis;
        }; 
        class Circle: public Ellipse { 
        public: 
             Circle(float radius) : Ellipse(radius, radius) {} 
             virtual void render();
         };
    ```
    ### 注意：
    - 一旦在基类 (`Shape`) 中将一个函数 (`render()`) 声明为 `virtual`，那么在所有继承链上的派生类中，这个函数就自动、永久地保持 `virtual` 属性。
    - 这意味着，即使你在 `Ellipse` 或 `Circle` 中省略 `virtual` 关键字，它仍然是一个虚函数，并且可以被更深层次的派生类（比如 `class HalfCircle : public Circle`）继续重写。
    - 即使在Circle或者Ellipse的.cpp文件中定义了`render`这个虚函数，它仍然是虚函数。

!!! concept "Example"
    ```c++
        void render(Shape* p){
            p->render();    // calls correct render function
        }
        void func(){
        Ellipse ell(10, 20);
        ell.render();
        Circle circ(40);
        circ.render();
        render(&ell);
        render(&circ);
        }
    ```
    
---
## Example
```c++
    #include<iostream>
    using namespace::std;
    class Point {public: float x, y;};   
    class Shape {
    public:
        Shape(){};
        void move(const Point& p){
            center = p;
        };
        virtual void render(){
           cout << "Shape render is called" << endl;
        };
        virtual void resize(){};
        virtual ~Shape(){};
    
    protected:
        Point center;
    };
    
    class Ellipse: public Shape{
    public:
        Ellipse(float major, float minor) : major_axis(major), minor_axis(minor){};
        virtual void render(){cout << "ellipse render called" << endl << "major_axis is " << major_axis << "    " << "minor_axis is " << minor_axis << endl;};
    protected:
        float major_axis, minor_axis;
    };
    
    class Circle: public Ellipse{
    public:
        Circle(float radius): Ellipse(radius, radius){}
        virtual void render(){cout<<"circle render is called" << endl;};
    };
    
    void render(Shape* p){
        p->render();
    };
    int main(){
        Ellipse ell(10, 20);
        ell.render();
        Circle circ(40);
        circ.render();
        render(&ell);
        render(&circ);
        
        Shape &s = circ;
        s.render();
        
        Shape &ss = ell;
        ss.render();
        
        Shape sss = circ;
        sss.render();
        
        Shape ssss =ell;
        ssss.render();
        return 0;
    }
```
![](附件/Pasted%20image%2020251121000729.png)

### 根据上面的example对Polymorphism进行总结
#### 1. 向上转型 (Upcast)

- **定义：** Upcast: take an object of the derived class as an object of the base one.
- **解释：** 向上转型是指将派生类对象（如 `Circle` 或 `Ellipse`）当作基类对象（`Shape`）来处理。
- **示例：** `Ellipse can be treated as a Shape`。
- **实现方式：** 这是通过 **基类指针**  (`Shape*`) 或 **基类引用**  (`Shape&`) 指向派生类对象来实现的。这是 C++ 中多态的基础。
    
#### 2. 动态绑定 (Dynamic Binding)

绑定是指程序确定要调用哪个函数的具体实现的过程。

- **静态绑定 (Static binding):**
    - “call the function as the declared type”
    - **何时发生：** 在编译时（Compile Time）确定。
    - **例子：** 调用非虚函数，或通过对象实例 (`ell.render()`) 调用函数。
        
- **动态绑定 (Dynamic binding):**
    - “call the function according to the **"real"** type of the object”
    - **何时发生：** 在运行时确定。
    - **条件：**
        1. 函数必须是**虚函数** (`virtual`)。
        2. 调用必须通过 **指针**  (`Shape* p`) 或 **引用**  (`Shape& r`)。
    - **效果：** 即使指针类型是 `Shape*`，如果它指向一个 `Circle`，系统也会调用 `Circle::render()`。这是多态的核心。

---

## How virtual works in c++ ?
![](附件/Pasted%20image%2020251121001534.png)
