上节课中我们通过以下代码实现了调用`Employee`的`print`函数来打印`pete`：
```c++
    Manager pete("Pete", "444-55-6666", "Bakery");
    Employee *ep = &pete; //upcast
    ep->print(cout);
```
如果说我们执行`ep->print(cout)`但是又不想用`Employee`的`print`函数，也就用pete实际的类型（`Manager`）而非被指代的类型（`Employee`）的print函数，就需要用到`Polymorphism`（多态）。

但是问题来了，我们明明将`ep`定义为了`Employee`类型，为什么还要调用`Manager`的`print`呢？既然这样为什么不执行`Manger *ep = &pete;`然后直接调用`Manager`的`print`呢？下面用一个drawing program来解释一下

---
## A drawing program
![](附件/Pasted%20image%2020251120171531.png)
!!! example "虚函数的意义"
    Circle、Rectangle、Ellipse全都继承自shape这个父类。shape会有一些公用的行为，图中的render（绘制）、move（移动）、resize（改变尺寸）都是它的公用行为。但是在定义shape这个父类的时候，没办法在这个类里面定义render函数（因为有这么多个类型的图形，我也不知道画哪一个）。
    
    这个时候只能构造所谓的 **虚函数** ，就是说`render`只是一个接口，只要是一个shape那就会有`render`这个函数，但是具体怎么实现就交给子类来定义。比如说circle这个子类就将render定义成画圆形的函数。
    
    定义好所有的子类形状之后，将所有的形状都up-casting成shape。这样之后，我的系统或者外部类类中就不需要知道它们具体是什么形状，只要调用render，就能各自object真实的类型对应的render的结果。

!!! conception "Inheritance in C++"
    ![](附件/Pasted%20image%2020251120174019.png)

!!! conception "Conceptual model"
    ![](附件/Pasted%20image%2020251120174519.png)
    
    - center()和move()可以直接定义在父类中，因为move()只是改变坐标，每个图形都一样，center()同理。
    - render()必须定义在子类中，上面已经讲过原因了。

!!! conception "Shape"
    ```c++
        class Point { ... }; // (x, y) point
        class Shape {
        public:
            Shape(); // 构造函数
            void move(const Point&); //&避免了二次开辟内存
            
            virtual void render();
            irtual void resize();
            virtual ~Shape(); // 虚析构函数
    
        protected:
            Point center; 
        };
    ```
    
    !!! warning "Question: 为什么Shape的析构函数也是虚函数"
        ```c++
            Shape* s_ptr = new Circle(5.0f); // 基类指针指向派生类对象
        ``` 
        我们执行了上述代码之后，如果Shape的析构函数不是虚函数，那么在解构~s_ptr时调用的就不是Circle的析构函数而是Shape的析构函数，然而Circle中定义了一些Shape中没有的东西，因此如果调用Shape的析构函数会导致内存释放不干净。

!!! conception "Add new shape"
    ```c++
        class Ellipse: public Shape{ 
        public: 
            Ellipse(float major, float minor); 
            virtual void render(); // will define own 
        protected: 
            float major_axis, minor_axis;
        }; 
        class Circle: public Ellipse { 
        public: 
             Circle(float radius) : Ellipse(radius, radius) {} 
             virtual void render();
         };
    ```
    ### 注意：
    - 一旦在基类 (`Shape`) 中将一个函数 (`render()`) 声明为 `virtual`，那么在所有继承链上的派生类中，这个函数就自动、永久地保持 `virtual` 属性。
    - 这意味着，即使你在 `Ellipse` 或 `Circle` 中省略 `virtual` 关键字，它仍然是一个虚函数，并且可以被更深层次的派生类（比如 `class HalfCircle : public Circle`）继续重写。
    - 即使在Circle或者Ellipse的.cpp文件中定义了`render`这个虚函数，它仍然是虚函数。

!!! concept "Example"
    ```c++
        void render(Shape* p){
            p->render();    // calls correct render function
        }
        void func(){
        Ellipse ell(10, 20);
        ell.render();
        Circle circ(40);
        circ.render();
        render(&ell);
        render(&circ);
        }
    ```
    
---
## Example
```c++
    #include<iostream>
    using namespace::std;
    class Point {public: float x, y;};   
    class Shape {
    public:
        Shape(){};
        void move(const Point& p){
            center = p;
        };
        virtual void render(){
           cout << "Shape render is called" << endl;
        };
        virtual void resize(){};
        virtual ~Shape(){};
    
    protected:
        Point center;
    };
    
    class Ellipse: public Shape{
    public:
        Ellipse(float major, float minor) : major_axis(major), minor_axis(minor){};
        virtual void render(){cout << "ellipse render called" << endl << "major_axis is " << major_axis << "    " << "minor_axis is " << minor_axis << endl;};
    protected:
        float major_axis, minor_axis;
    };
    
    class Circle: public Ellipse{
    public:
        Circle(float radius): Ellipse(radius, radius){}
        virtual void render(){cout<<"circle render is called" << endl;};
    };
    
    void render(Shape* p){
        p->render();
    };
    int main(){
        Ellipse ell(10, 20);
        ell.render();
        Circle circ(40);
        circ.render();
        render(&ell);
        render(&circ);
        
        Shape &s = circ;
        s.render();
        
        Shape &ss = ell;
        ss.render();
        
        Shape sss = circ;
        sss.render();
        
        Shape ssss =ell;
        ssss.render();
        return 0;
    }
```
![](附件/Pasted%20image%2020251121000729.png)

### 根据上面的example对Polymorphism进行总结
#### 1. 向上转型 (Upcast)

- **定义：** Upcast: take an object of the derived class as an object of the base one.
- **解释：** 向上转型是指将派生类对象（如 `Circle` 或 `Ellipse`）当作基类对象（`Shape`）来处理。
- **示例：** `Ellipse can be treated as a Shape`。
- **实现方式：** 这是通过 **基类指针**  (`Shape*`) 或 **基类引用**  (`Shape&`) 指向派生类对象来实现的。这是 C++ 中多态的基础。
    
#### 2. 动态绑定 (Dynamic Binding)

绑定是指程序确定要调用哪个函数的具体实现的过程。

- **静态绑定 (Static binding):**
    - “call the function as the declared type”
    - **何时发生：** 在编译时（Compile Time）确定。
    - **例子：** 调用非虚函数，或通过对象实例 (`ell.render()`) 调用函数。
        
- **动态绑定 (Dynamic binding):**
    - “call the function according to the **"real"** type of the object”
    - **何时发生：** 在运行时确定。
    - **条件：**
        1. 函数必须是**虚函数** (`virtual`)。
        2. 调用必须通过 **指针**  (`Shape* p`) 或 **引用**  (`Shape& r`)。
    - **效果：** 即使指针类型是 `Shape*`，如果它指向一个 `Circle`，系统也会调用 `Circle::render()`。这是多态的核心。

---

## How virtual works in c++ ?

### Vtable: 用于存储虚函数的`地址`(注意是地址！！！)

### Shape
![](附件/Pasted%20image%2020251121001534.png)
如果一个类里面有虚函数，那么c++就会在这个类里面创建一个`virtual ptr`指针，这个指针指向虚函数表。这个虚函数表用于存放虚函数的实际地址。
### Ellipse
![](附件/Pasted%20image%2020251121203624.png)
右侧部分的绿色区域是从`Shape`中继承过来的，蓝色部分是`Ellipse`中新增的。`Ellipse`中的`dtor()`（析构函数）和`render()`都是与`Shape`中不同的。但是并没有对`resize`重载，所以`resize`继承的仍然是`Shape()`的`resize()`。

#### 注意：
虽然`Ellipse`中的`vptr`是绿色的，但是它的值跟`Shape`中的`vptr`的值是不一样的。

### Circle
![](附件/Pasted%20image%2020251121205211.png)
这幅图与上一幅图相反，绿色区域是自己新增的，蓝色部分是继承的。

---

## Example
```c++
    #include<iostream>
    #include<cstdint>
    using namespace::std;
    
    class A{
    public:
        A(){
            i=10;
            cout << "A() " << endl;
        }
        ~A(){
            cout << "~A()" << endl;
        }
        virtual void f(){
            cout << "A::f() " << i << endl;
        }
        virtual void g(){};
        
    public:
        int i;
    };
    
    class B: public A{
    public:
        B(){
            j=20;
            cout << "B() " << endl;
        }
        ~B(){
            cout << "~B() " << endl;
        }
        virtual void f(){
            cout << "B::f() " << j << endl;
        }
        
    public :
        int i;
        int j;
    };
    
    int main(){
        cout << "The size of A is " << sizeof(A) << "; " << "The size of B is " << sizeof(B) << endl;
        
        return 0;
    }
```
### (1): 上述代码的运行结果如下：
![](附件/Pasted%20image%2020251121212009.png)
### (2):  如果将虚函数注释掉，得到的结果如下：
![](附件/Pasted%20image%2020251121212812.png)

!!! explanation
    ### 加上虚函数之前
    A中的int占了4个字节。B中有A中的i以及B中自身的i与j，总共占了12个字节，函数本身是不占用内存的，因此在没有虚函数的时候，输出结果会是4与12。
    
    ### 加上虚函数之后
    虽然虚函数本身没有内存，但是存在地址。引入了虚函数之后，会开辟一个`vptr`指针用于存储虚函数的地址。这个例子中可以看出A与B的ptr都占用了12个字节的内存。
### (3): 在(2)的基础上，加上下述代码后的运行结果：
```c++
    A a;
    B b;
    cout << &a << ", "<< &b << endl;
    
    void* pa=(void*)&a;
    void* pb=(void*)&b;
    cout << pa << ", " << pb << endl;
    
    return 0;
```
![](附件/Pasted%20image%2020251122000938.png)
!!! warning "为什么要在`&a`与`&b`前面加上`(void*)` ?"
    在这段代码中&a与&b返回的分别是A类型和B类型的指针，但是pa与pb是`(void*)`类型的，虽然这段代码中，我用`void* pa = &a;`和`void* pb = &b;`也成功编译出了一样的结果但是在有些编译器中可能会报错。
    
    `pa`与`pb`存储的分别是`a`与`b`的地址，因此打印`&a`与`&b`得出的结果跟打印`pa`与`pb`是一样的。

### (4): 在(3)的基础上，加上下述代码后的运行结果：
```c++
    int64_t* val_pa = (int64_t *)pa;
    int64_t* val_pb = (int64_t *)pb;
    cout << "hex: " << hex << *val_pa << ", " << *val_pb << endl;
```
![](附件/Pasted%20image%2020251122011624.png)
!!! explanation
    `hex`会让之后的所有`cout`都以16进制输出的意思
    
    `val_pa`与`val_pb`存储的不是`pa`与`pb`的地址，而是它们本身的值，而`pa`与`pb`本身的值就是`a`与`b`的地址，因此`*val_pa`与`val_pb`输出的分别是`a`与`b`这两个地址中存储的值，也就是`a`与`b`自身的值，及它们各自的`vptr`值。

### (5): 在(4)的基础上，加上下述代码后的运行结果：
```c++
    void * * pvptra = (void * *) pa;
    void * * pvptrb = (void * *) pb;
    cout << *pvptra << ", " << *pvptrb << endl;
```
![](附件/Pasted%20image%2020251122012723.png)
!!! explanation
    `void * * pvptra = (void * *) pa;`意为创建一个`(void * *)`类型的指针，`(void * *) pa`意为将`pa`强制转化成`void* *`类型。因此这句话的含义是创建一个二级指针`pvptra`，它指向的值是`pa`的地址中存储的值而不是`pa`的地址，也就是说它指向`a`的地址。因此操作(5)跟操作(4)其实是一样的，只是一个以10进制输出，一个以16进制输出。

### (6): 在(5)的基础上，加上下述代码，并将f函数的注释删掉后的运行结果：
```c++
    void * * ppa = (void * *)&a;
    void * * ppb = (void * *)&b;
    
    cout << *ppa << ", " << *ppb << endl;
    
    A *ptr = &a;
    ptr->f();  //dynamic a
    a.f();   //static a
    
    *ppa=*ppb;
    ptr->f();   //dynamic b
    a.f();   //static a
```
![](附件/Pasted%20image%2020251122020130.png)
!!! explanation
    ppa指向的是a的地址，因此`*ppa`是`a`中的`ptr`存储的值，`ptr`存储的是`Vtable`的地址，因此`a`的`ptr`中存储的Vtable的地址变成了`b`中的`Vtable`的地址，故执行`ptr->f();`后使用的是`B`中的`f()`函数。
    
    那么为什么`a.f()`仍然不变呢，那是因为`a.f()` 是通过对象实例直接调用的。C++规定通过对象实例调用虚函数时，必须使用静态绑定。静态绑定在编译时就根据变量的声明类型（`A a`）确定了函数地址，直接将调用指令硬编码为 `A::f()`。因此即使`*ppa`变为了`*ppb`，执行`a.f()`;后打印的仍然使用的是`B`的f()函数
    
    为什么`B`函数后面打印出来的`j不是20的16进制，而是一串奇奇怪怪的数字呢？首先，`ptr`与`ppa`存储的都是`a`的地址，也就是`&a`。`*ppa`改变意味着`*ptr`改变，而不是`ptr`改变。`*ptr`改变说明`a`指向的值，也就是`Vtable`的地址发生了改变，但是`ptr`本身没变，所以仍然与`a`绑定，`a`中没有`j`，而此时要求输出`j`，因此会随机输出一个数，而不是输出20。