```c++
    int a[5] = {1, 2, 3, 4, 5};
    
    int b[6] = {5};
    
    int c[] = {1, 2, 3, 4}; 
        数组大小没有显式指定。
        编译器会根据初始化列表中的元素数量自动确定数组大小。
        结果：c 的大小是 4，元素是 {1, 2, 3, 4}。
        sizeof c / sizeof *c:
            这是一个计算数组元素数量的经典 C/C++ 惯用法。
            sizeof c：数组 c 占用的总字节数（4 个 int 的大小）。
            sizeof *c：第一个元素 *c（即 c[0]，一个 int）占用的字节数。
            结果：总大小 / 单个元素大小 = 元素数量（即 4）。
        
    struct X{
        int i;
        float f;
        char c;
    };
    X x1 = {1, 2.2, 'a'};
    X x2[3] = {{1, 2.2, 'a'},{3, 3.4, 'c'}};
        第三个元素 x2[2] 没有显式初始化，因此会被零初始化,即{0, 0.0, '\0'}。
        
    struct Y{
        int i;
        float y;
        Y(int a);
    };
```

!!! explanation "为什么X2[2]中的元素是被零初始化而不是被随机赋值"
    当使用花括号 {} 列表对聚合体（例如这个结构体数组 x2）进行初始化时，如果初始化列表中的元素数量少于聚合体中的成员数量（或数组的容量）：
    
    1. 显式初始化的成员或元素使用列表中的值。
    2. 剩余未显式初始化的成员或元素将进行值初始化。
    
    值初始化的结果：
    
    对于内置类型（如 int, float, char），当它们进行值初始化时，其结果就是零初始化。因此，x2[2] 这个结构体的所有成员（i、f、c）都会被设置为零：
    
    ![](附件/Pasted%20image%2020251021222238.png)
    
    虽然 x2 是一个局部变量（通常默认初始化会得到随机值），但是因为它使用了花括号 {} 列表来进行初始化（即聚合初始化）：
    1. 前两个元素（x2[0] 和 x2[1]）得到了您指定的值。
    2. 第三个元素（x2[2]）属于“剩余未初始化的元素”，因此遵循值初始化规则。
    3. 值初始化保证了它的所有内置类型成员（i, f, c）都被设置为 0。
    
    简而言之：只要您使用了花括号 {} 列表对聚合体进行初始化，C++ 编译器就会确保所有未显式初始化的部分得到一个确定的零值，从而避免不确定（随机）的值。
    
    `X x3[3]; // 默认初始化，没有使用 {}`
    此时，x3 的 3 个元素都会被默认初始化，并且它们的内容将是随机/不确定的。

!!! explanation "Y(int a) 的真实含义：构造函数的声明"
    在 C++ 中，结构体 (struct) 和 类 (class) 几乎是同义词（唯一的区别是默认的访问权限）。在结构体或类内部，如果一个函数的名称和结构体的名称完全相同，那么它就不是一个普通的函数，而是一个构造函数 (Constructor)。所以，Y(int a); 的意思是：
    
    这是一个 Y 结构的构造函数。它接收一个 int 类型的参数 a。
    
    ### Question:为什么它只写了 Y(int a); ?
    
    ### Answer:就像普通函数一样，构造函数也可以将声明（原型）和定义（函数体）分开：
    
    Y(int a); 这一行是构造函数的声明（或者说，原型）。它告诉编译器：“这个 Y 类有一个接收int的构造函数”。
    一旦在结构体 Y 中自己定义了构造函数 Y(int a)：
        
        - Y 不再是一个聚合体。
        - 编译器将不再自动为你生成默认构造函数 Y()。
        - 不能再使用简单的聚合初始化（如 Y y = {1.0, 5};）。
        - 必须使用带 int 参数的构造函数来创建对象，例如 Y y(10);。
    
    简而言之，Y(int a) 就是这个结构体 Y 的带参数初始化函数。
    
    ### Question:可是Y里面不是有一个float还有一个int嘛，为什么只这里面是Y(int a)而不是Y(int a, float b)?
    
    ### Answer:
    1. 构造函数可以只用部分信息初始化，程序员设计 Y(int a) 可能意味着：
    
        - a 用来初始化 int i。
        - float f 在逻辑上总是应该有一个默认值（比如 0.0f 或一个固定常量），不需要从外部传入。
    
    2. 构造函数可以执行内部计算： 传入的 a 可以用于计算所有成员的值。例如：
        - i 初始化为 a。
        - f 初始化为 a 的平方根或 a 的某个倍数。

---
## The default constructor

### 默认构造函数的定义:

A default constructor is one that can be called with no arguments. （默认构造函数是可以不带参数调用的构造函数。）

类型： 默认构造函数包括两种：

- 没有参数的构造函数（例如 Y()）。
- 所有参数都有默认值（例如 Y(int a = 0)）。

!!! example 
    下图中只有`Y y1[] = {Y(1), Y(2), Y(3)}`是合法的
    ![](附件/Pasted%20image%2020251021230655.png)

---

## auto default constructor

1. If you have a constructor, the compiler ensures that construction always happens.

    - 保证初始化： 无论对象是如何创建的（在栈上、堆上或作为数组元素），只要一个类有构造函数，编译器就会自动调用它，确保对象在被客户端代码使用之前总是被构造和初始化。

2. If (and only if) there are no constructors for a class (struct or class), the compiler will automatically create one for you.

    - 自动生成条件： 编译器只会在类中没有定义任何构造函数（无论是带参数的还是无参数的）时，才会自动为你生成一个默认构造函数（即无参数构造函数）。
    - 关键推论： 如果程序员自己定义了任何一个构造函数（例如 Y(int a)），那么编译器会假定程序员已经完全接管了对象的初始化工作，将不再自动生成无参数的默认构造函数 Y()。
    - 后果： 正是这个规则导致了您之前示例中的问题：一旦自定义了 Y(int a)，任何需要调用 Y() 的代码（例如 Y y4; 或数组的不完全初始化）就会因为找不到默认构造函数而报错。

结论：

- 如果你一个构造函数都没写，编译器会帮你写一个默认的。
- 如果你写了任何一个构造函数，编译器就认为你了解情况，不再帮你写无参数的默认构造函数。
- 因此，当自定义了构造函数后，若还需要无参数构造，程序员必须手动定义 MyClass()。

---

## Local variable vs. Field
```c++
    int TicketMachine::refundBalance() {
        int amountToRefund; // 本地变量
    
        amountToRefund = balance; // balance是字段，被定义在 TicketMachine 类的内部
        balance = 0;
    
        return amountToRefund;
    }
```

refundBalance() 这个函数不是一个独立的全局函数。它是属于 TicketMachine 这个类或结构体的一个成员函数（Method）。

- **`amountToRefund`**: 这是一个在函数 `refundBalance()`  **内部** 声明的变量。
- **`balance`**: 这是一个没有在函数内部声明的变量，它属于 `TicketMachine` 类的 **成员** 或 **字段** 。
    
#### 生命周期 (Lifetime) 的区别

- **`amountToRefund` is with the function call**
    
    -  **本地变量** 的生命周期只存在于函数 **被调用期间** 。
    - 当函数 `refundBalance()` 开始执行时，`amountToRefund` 被创建；当函数执行完毕返回时，`amountToRefund` **立即被销毁** （超出作用域，就像前面提到的析构函数调用机制一样）。
    
- **`balance` is with the object, i.e., object state**
    
    -  **字段/成员变量** 的生命周期与 **对象本身** 的生命周期一致。
    - `balance` 存储了对象的状态，它在 `TicketMachine` 对象被 **创建时** 产生（通过构造函数初始化），直到对象被 **销毁时** 才消失（通过析构函数清理）。
        
### 总结

本地变量用于 **临时计算** ，它们只在函数执行期间存在。字段用于保存对象的状态，它们的生命周期与对象一致，并在对象之间传递信息。这种区别是实现 **封装**  和对象持久化状态的基础。

!!! tips "A local variable of the same name as a field will prevent the field from being accessed within a method."
    
    - 本地变量（Local Variable）： 这是一个在类成员函数（方法）内部定义的变量。
    - 字段/成员变量（Field）： 这是一个在类结构中定义，存储对象状态的变量。
    
    ### 作用域和名称遮蔽 (Name Shadowing)
    
    这条规则描述了 C++ 中的 **名称遮蔽** 现象：
    
    1. 就近原则： 当编译器在一个方法内部查找一个变量名时，它会遵循 **“就近原则”，首先在最内层的作用域** （即函数内部）查找。
    2. 名称遮蔽： 如果在方法内部找到了一个本地变量与类的字段同名，那么本地变量就会遮蔽（或隐藏）同名的字段。
    3. 结果： 在该方法内部，所有对这个变量名的引用都将指向本地变量，导致无法直接访问同名的字段。

!!! example
    ```c++
        class TicketMachine {
        private:
            int balance; // 字段 (Field)
        public:
            void processPayment(int amount) {
            int balance; // 本地变量 (Local Variable)
        
            balance = 100; // ❗ 这一行修改的是本地变量 balance
        
            // ❌ 无法直接访问字段 balance
            // ❌ 导致字段 balance 保持不变
            }
        };
    ```

    为了在这种情况下访问被遮蔽的字段，需要使用作用域解析运算符 :: 或 this-> 指针：
    ```c++
        // 访问字段 balance
        this->balance = 100;
    ```

---

## Field, parameters and local variables

- All three kinds of variable are able to store a value that is appropriate to their defined type.

    - 共同点： 无论是字段、参数还是本地变量，它们都具有一个类型（例如 int, float），并且能够存储该类型的值。

- Fields are defined outside constructors and methods

    - 定义位置： 字段（成员变量）不是在函数或构造函数内部定义的，而是在类或结构体的主体中定义的。它们是类定义的一部分，通常放在头文件（.h）中。

- Fields are used to store data that persists throughout the life of an object. As such, they maintain the current state of an object. They have a lifetime that lasts as long as their object lasts.

    - 核心作用： 字段用于存储贯穿对象整个生命周期的数据。
    - 状态管理： 它们是对象当前状态的载体。
    - 生命周期： 它们的生命周期与它们所属的对象的生命周期相同（与本地变量只存在于函数调用期间不同；当对象被销毁时，字段也会随之消失）。

- Fields have class scope: their accessibility extends throughout the whole class, and so they can be used within any of the constructors or methods of the class in which they are defined.
    - 作用域： 字段拥有类作用域。
    - 可访问性： 这意味着一个字段可以被该类的任何构造函数、析构函数 或其他成员方法访问和使用，这是因为它们共享对象内存。

---

## Call the functions in a class
```c++
    Point a;
    a.print();
```
- `Point a` 创建了一个 Point 类型的对象 a。在这一步，Point 的构造函数被自动调用，保证了对象 a 的初始化。

- `a.print()` 是调用Point 类的 print 成员函数（方法）。

### 核心要点

- There is a relationship with the function be called and the variable to call it.

    - 关系： 在面向对象中，函数（方法）print() 总是与调用它的特定对象（变量）a 紧密关联。
    - 区别： 这与传统的过程式编程中的全局函数调用（如 print(a)）不同。在这里，函数是对象的一部分。

- The function itself knows it is doing something with the variable.

    - 自我感知： 当 print() 函数被调用时，它自动知道它是在对哪个对象（即 a）进行操作。
    - 实现机制： 在 C++ 内部，编译器通过将一个隐藏的指针 this 传入 print() 函数来实现这一点，this 指针指向对象 a 的内存地址。这样，print() 就可以访问和操作对象 a 内部的字段（成员变量）（例如，a 的坐标数据）。

#### 总结
这张图描述了 OOP 中的“消息传递” 概念：程序是由对象通过发送消息a.print()来告诉彼此要做什么。print 方法接收到消息后，根据它被哪个对象调用（即 a），来操作那个对象的状态（a 的内部数据）。

--- 

## this: the hidden paremeter

**`this` is a hidden parameter for all member functions, with the type of the class.**

- **隐藏参数：** `this` 是一个 **隐含的** 参数，由 C++ 编译器自动添加到每一个非静态成员函数的参数列表中。
- **类型：** 它的类型是 **指向所属类类型** 的指针（例如 `Point*`）。

```c++
    void Point::print()
    
    void Point::print(Point *this)
```

- **语义等价：** 编译器处理 `Point` 类的 `print()` 成员函数时，实际上可以将其视为一个接收一个 `Point*` 参数的函数。这个参数就是 `this`。    
- **作用：** 当您调用 `a.print();` 时，编译器会把对象 `a` 的地址作为 `this` 参数传递给 `print()` 函数。


### 总结

`this` 指针是 C++ 实现 **OOP 消息传递** 的关键机制。它允许成员函数：

1. **识别对象：** 知道它正在操作的是哪个对象实例。
    
2. **访问状态：** 通过 `this` 指针，函数可以访问和修改当前对象实例的**字段（成员变量）**（例如，访问 `this->x` 或 `this->y`），从而维护对象的持久状态。

---
To call the function, you must specify a variable

- 前提： 要调用类的非静态成员函数（方法），你必须通过一个具体的对象实例（一个变量）来调用它，例如 a.print()。这是面向对象中消息传递的体现。

```c++
    Point a;
    a.print();

    Point::print (&a);
```

- 左侧（程序员代码）： a.print() 是程序员编写的简洁的面向对象调用。

- 右侧（概念等价）： Point::print (&a); 描述了编译器在底层做的事情。它将 a.print() 的调用转化为一个普通函数调用，其中：

    - Point::print：使用作用域解析运算符 (::) 来明确指定要调用的函数是 Point 类的 print 方法。

    - (&a)：将对象 a 的地址（通过 & 运算符获取）作为一个参数传入这个函数。

### 与 this 的关联：
这个地址 &a，在 Point::print 函数的内部，就是那个隐藏的 this 指针的值。

- this = &a
- 编译器将 a.print() 转换为 Point::print(this = &a)，从而允许 print 函数通过 this 指针访问对象 a 的内部数据（字段）。


---

## the pointer to the caller

1. Inside member functions, you can use this as the pointer to the variable that calls the function.

    - 作用： 在类成员函数（方法）内部，this 可以作为一个指针来使用，它指向的是 **调用该函数的那个对象实例。**
    - 用途： 这使得成员函数能够访问和修改该对象实例的字段（成员变量），特别是用于解决名称遮蔽问题。

2. "this" is a natural parameter of all class member functions that you cannot define, but can use directly.

    - 性质： this 是所有类成员函数的自然参数（即自动参数）。
    - 不可定义性： 程序员不能在函数参数列表中显式声明或定义 this（尽管它在概念上被视为一个隐藏参数）。
    - 可直接使用性： 尽管它被隐藏，程序员在函数体内部却可以直接使用 this 关键字（通常使用 this->member 的形式）。

### 总结
this 指针是 C++ 实现面向对象中 **“方法作用于特定对象”** 这一原则的基石。它是一个由编译器默默传入的指针，使得每个成员函数都能精确地知道自己正在操作的是哪个对象的内存状态。