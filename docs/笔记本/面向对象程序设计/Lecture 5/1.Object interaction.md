## Object oriented programming（）
![](附件/Pasted%20image%2020251016230656.png)

---

## Object send message
### 消息的组成和处理
1. Messages are (消息是):

    - Composed by the sender (由发送者构成/编写):
        
        - 发送者（一个对象）决定了要向目标对象请求什么操作。这通常是通过调用一个方法来实现的，但从概念上讲，它是构造了一个“消息”包，包含了要调用的方法名和任何必要的参数。
        
    - Interpreted by the receiver (由接收者解释):
        
        - 接收者（另一个对象）收到消息后，会根据自己的类型/类来决定如何响应这个消息。这个过程就是“方法查找”和“方法执行”。这是实现多态性（Polymorphism）的关键：不同的对象可以接收相同的消息，但会以自己的方式解释和处理它。
        
    - Implemented by methods (由方法实现):
        
        - 消息的实际处理逻辑驻留在接收者对象所属类中定义的一个方法（Method）内部。方法是包含指令的代码块，用于执行消息所请求的操作。

### 消息的后果
2. Messages (消息):

    - May return results (可能返回结果):

        - 就像函数调用一样，一个消息可以请求接收者计算并返回一个值给发送者。

    - May cause receiver to change state, i.e., side effects (可能导致接收者改变状态，即，产生副作用):

        - 这是消息传递最重要的后果之一。一个消息通常被设计用来改变接收者对象内部的数据（状态）。

        - 状态改变 (Side Effects)： 这是指对象内部的实例变量（Instance Variables/属性）的值发生了变化。例如，一个 Account 对象接收到 deposit(amount) 消息后，它的内部状态（balance）就会增加。

### 总结
程序不是由一系列按顺序执行的指令组成的，而是由名词（对象）通过相互传递动词（消息）来驱动的。这种模型强调了对象的自治性、封装性以及它们通过接口（消息）进行交互的重要性。

---

## Encapsulation（封装）
1. Bundle data and methods dealing with these data together in an object (将数据和处理这些数据的方法捆绑在一个对象中)

    - 概念： 这是封装的**组合（Grouping）**方面。一个对象是结构（数据/属性/状态）和行为（方法/函数）的统一体。它将对象的状态（数据）与其操作（方法）紧密地结合在一起。

    - 意义： 这就是 OOP 区别于过程式编程的地方，它确保了数据和操作数据的代码总是同步的。

2. Hide the details of the data and the action (隐藏数据和操作的细节)

    - 概念： 这是封装的**信息隐藏（Information Hiding）**方面。对象内部的数据和实现方法（例如，某个计算是如何完成的）对外部世界是隐藏的。

    - 意义： 这极大地提高了代码的健壮性和可维护性。外部用户不需要知道对象内部是如何工作的，只需要知道如何通过接口来使用它。如果内部实现改变了（例如，从数组换成链表），只要外部接口不变，使用该对象的代码就不需要修改。

3. Restrict access only to the publicized methods (限制访问只通过公开的方法)

    - 概念： 这是封装的**访问控制（Access Control）**方面，通常通过编程语言的访问修饰符（如 C++ 中的 public, private, protected）来实现。

    - 实现： 对象的数据通常被声明为 private，只能通过对象提供的一组公开 (public) 方法（有时称为 Getter 和 Setter 或 Accessors 和 Mutators）来读取或修改。

    - 意义： 这样可以确保对对象状态的所有更改都是可控且有效的。对象可以确保其数据始终处于一个合法的状态（例如，一个银行账户余额不能为负数），防止外部代码意外或恶意地破坏对象的状态。

### 总结：
封装 = 组合 + 信息隐藏 + 访问控制。它是构建可靠、模块化和易于维护的面向对象系统的基石。

---

## Abstract
1. Abstraction is the ability to ignore details of parts to focus attention on a higher level of a problem. (抽象是一种忽略部分细节的能力，以便将注意力集中在问题的更高层次上。)

    - 核心思想： 抽象是管理复杂性的最重要手段。它关注 **“做什么”，而不是“如何做”** 。

    - 例子： 当您驾驶汽车时，您不需要知道引擎是如何点火或活塞是如何运动的（这些是低层细节），您只需要关注油门、刹车和方向盘（这些是高层抽象）。

    - 在 OOP 中： 抽象体现在 **接口（Interfaces）和抽象类（Abstract Classes）** 上。它们定义了一组操作（行为），但将这些操作的具体实现（细节）留给子类或实现类去完成。

2. Modularization is the process of dividing a whole into well-defined parts, which can be built and examined separately, and which interact in well-defined ways. (模块化是将一个整体分成定义良好的部分的过程，这些部分可以单独构建和检查，并以定义良好的方式相互作用。)

    - 核心思想： 模块化是分解复杂系统的过程。它关注 **“如何组织”**代码。

    - 目的：
        - 单独构建和检查： 允许独立开发、测试和维护代码的不同部分（即您前面看到的 .h 和 .cpp 文件的分离，以及编译单元的概念）。

        - 定义良好的交互： 模块之间通过清晰、稳定的接口（这些接口正是抽象的结果）进行通信，减少了模块间的相互依赖和影响。

    - 在 C++ 中： 模块化体现在将代码分解为不同的头文件和源文件，将相关的功能组织成类、命名空间或库。

### 抽象与模块化的关系

- 抽象是一种思维工具或设计哲学，用于识别重要的概念（接口）并忽略不重要的细节（实现）。

- 模块化是一种组织技术或工程实践，用于将抽象出的概念（例如，一个类或一个功能组）封装到独立、可替换的代码块（模块）中。

可以说，抽象是模块化实现的基础。先通过抽象定义出系统的“什么”和“如何交互”，然后通过模块化将其组织和实现。

---
## Modularizing the clock display
![](附件/Pasted%20image%2020251021134320.png)
将四个数字的时钟变成两个一个双显示器的时钟
![](附件/Pasted%20image%2020251021134345.png)
![](附件/Pasted%20image%2020251021134410.png)
!!! implementation "Implementation-ClockDisplay"
    ```c++
        class ClockDisplay{
            NumberDisplay hours;
            NumberDisplay minutes;
        }
        class Number Display{
            int limit;
            int value;
        }
    ```
    
---
