
!!! example "Point::init()"
    ```c++
        class Point {
            public:
                void init (int x, int y);
                void print () const;
                void move (int dx, int dy);
                
            private:
                int x;
                int y;
        }
        Point a;
        a.init(1, 2);
        a.move(2 ,2);
        a.print();
    ```


---
## Guaranteed initialization with the constructor

1. **If a class has a constructor, the compiler automatically calls that constructor at the point an object is created, before client programmers can get their hands on the object. (如果一个类有构造函数，编译器会在对象被创建时自动调用该构造函数，在客户端程序员能够操作该对象之前。)**
    
    - **核心作用：** 构造函数（Constructor）是用来 **初始化** 对象的。
        
    - **自动调用：** 无论对象是在栈上、堆上还是全局数据区创建，只要对象被实例化，编译器就会 **自动且强制** 调用其构造函数。
        
    - **“Guaranteed initialization”：** 正是这种自动和强制调用的特性，保证了对象在被外部代码使用 **之前** ，其内部成员变量都处于一个已知、有效的初始状态。这避免了使用未初始化数据（这是 C++ 中常见的错误来源）。
        
2. **The name of the constructor is the same as the name of the class. (构造函数的名称与类的名称相同。)**
    
    - **命名规则：** 这是一个语法规则。在 C++ 中，构造函数是一种特殊的方法，它没有返回类型（甚至不能是 `void`），并且必须与它所属的类的名称完全相同。
        

---
## Constructor

我们需要有机制，保证对象被创建时有合理的初值，如果没有赋初值，那么对象的状态就是不确定的，这时候就需要构造函数（Constructor）

C++ 中，对象创建时，其状态（成员变量）如果不初始化，就是 **不确定的** （可能包含随机垃圾值）。构造函数是用来 **强制保证** 对象在被使用前处于一个合理、已知的初始状态的机制。

- 构造函数名字和结构名字完全相同，没有返回类型
- 如果没有定义构造函数，编译器会自动生成一个默认构造函数，默认的构造函数没有任何参数
    - ![](附件/Pasted%20image%2020251021212449.png)
- 本地变量被创建时，构造函数被调用

!!! example "Example"

    构造函数的定义一般有下列形式：
    
    ```c++
	    #include`<iostream>`
	    using namespace std;
        
        struct Y{
		    int i;
		    float x;
		    Y(int a) { i = a; }
	    };

        int main(){
		    Y y1[2] = {Y(1), Y(2)};
	    }
	```
    
    这样是没问题的，但是如果我们将`y1` 的长度设置为 3，那么会报错：
    
    这是因为`Y y1[3]` 会调用默认构造函数，即 `Y y1[3] = {Y(1), Y(2), Y()}`，但是我们已经定义了一个构造函数，编译器不会再自动生成默认构造函数，因此第三个Y便不会被随机赋值一个参数，这就会导致错误：

    ```c++
	    #include`<iostream>`
	    using namespace std;
    
        struct Y{
		    int i;
		    float x;
		    Y(int a) { i = a; }
		    Y() {}
	    };
    
        int main(){
		    Y y1[3] = {Y(1), Y(2)};
	    }
	```
    
    - 事实上，有了默认构造函数，我们甚至可以直接使用`Y y1[3]`，不需要再赋初值，因为不传参的时候系，默认构造函数会随机给定一个参数

---

## Destructor

在对象的生命周期结束时，我们需要有机制来释放资源，这时候就需要析构函数（Destructor）

- 析构函数名字和结构名字完全相同，前面加上 `~`，没有返回类型
- 对象即将结束生命周期时，析构函数被调用
- 析构函数没有参数

1. In C++, cleanup is as important as initialization and is therefore guaranteed with the destructor. (在 C++ 中，清理工作与初始化同等重要，因此由析构函数来保证。)

    - 核心作用： 析构函数的目的是在对象被销毁时执行必要的清理工作。

    - 自动调用： 就像构造函数一样，析构函数也是自动且强制调用的。它在对象的生命周期结束时被调用，例如：
        - 栈上对象离开作用域时。
        - 堆上对象被 delete 时。
        - 程序结束时（对于全局对象）。

    - “清理工作”： 最重要的清理工作是释放对象通过 new 或 new[] 在堆上动态分配的内存，以及释放任何打开的文件句柄、网络连接等资源。

2. The destructor is named after the name of the class with a leading tilde (~). The destructor never has any arguments. (析构函数以类名命名，并在前面加上一个波浪号（~）。析构函数永远不会有任何参数。)

    - 命名规则： 析构函数的名称就是类名，前面加上一个波浪号 ~。例如，如果类名是 Car，析构函数就是 ~Car()。

    - 参数限制： 析构函数不能接受任何参数，因此一个类只能有一个析构函数。

## When is a destructor called ?

> **The destructor is called automatically by the compiler when the object goes out of scope.** （当对象超出其作用域时，析构函数会被编译器自动调用。）

- **析构函数 (`~ClassName()`)：** 负责执行对象生命周期结束前的清理工作（如释放动态分配的内存、关闭文件、断开网络连接）。
    
- **自动调用：** 像构造函数一样，析构函数也是由 **C++ 编译器自动强制调用** 的，保证了资源会被及时释放。
    
- **超出作用域 (Goes Out of Scope)：** 这是指对象在其被定义的 **代码块** （通常是花括号 `{}` 括起来的区域）结束时。

---
## Storage allocation

- The compiler allocates all the storage for a scope at the opening brace of that scope. (编译器在作用域的起始花括号处就为该作用域内的所有存储空间进行分配。)

    - 分配时机： 这里的“分配”指的是为局部变量（在栈上）预留出原始的内存空间。
    - 目的： 这是一个优化行为。编译器为了效率，可能会在进入一个函数或代码块（即遇到 { 时）就一次性计算并调整栈指针，为该块内所有的局部变量提前准备好内存空间。
    - 状态： 在这个时间点，这块内存里是随机的垃圾数据，对象还没有被初始化。

- The constructor call doesn't happen until the sequence point where the object is defined. (构造函数调用直到对象被定义的顺序点才会发生。)

    - 初始化时机： 尽管内存可能提前分配好了，但对象的逻辑初始化（即执行构造函数内的代码）仍然严格发生在代码中定义该对象的那一行语句处。
    - 保证顺序： 构造函数是确保对象具有有效状态的机制。这条规则保证了：在代码执行到 MyClass obj; 这一行之前，构造函数不会运行，从而保证对象在构造完成之前不会被后续代码访问或使用。

### 总结：C++ 局部变量生命周期中的两个阶段：

- 物理存储准备 (Allocation)： 可能在作用域开始时就完成（优化）。
- 逻辑初始化 (Construction/Initialization)： 严格发生在对象的定义语句处。

这保证了 C++ 程序行为的正确性和可预测性。

!!! example
    ```c++
        #include<iostream>
        using namespace std;
        
        class Tree{
            int height;
        public:
            Tree (int initialHeight); //Constructor
            Tree (); //无参数的构造函数
            ~Tree(); //Destructor
            void grow (int year);
            void printsize();
        };
        
        Tree::Tree(){
            height = 0;
        }
        
        Tree::Tree(int initialHeight){
            cout << "Inside construction" << endl;
            height = initialHeight;
        }
        Tree::~Tree(){
            cout << "Inside destruction" << endl;
            printsize();
        }
        
        void Tree::printsize(){
            cout << "The height is " << height << endl;
        }
        
        void Tree::grow(int year){
            height = height + year;
        }
        
        int main(){
            cout << "Before opening brace" << endl;
            Tree t;
            {
                Tree t(12);
                cout << "After Tree creation" << endl;
                t.printsize();
                t.grow(4);
                cout << "Before closing brace";
            }
            cout << "After closing brace";
            return 0;
        }
    ```
    
    ### 最终的输出结果如下：
    ![](附件/Pasted%20image%2020251022172306.png)
    
    !!! tip
        这段代码中的两个Tree对象t并不是同一个东西，它们会在各自的作用域结束时自动调用析构函数进行解构。
        
        1. 内部对象(Tree t(12);这句话定义的t)的解构：
            
            - 定义：Tree t(12);
            - 作用域： 它的作用域是 main 函数内部的嵌套代码块 {}。
            - 析构时间： 它将在该嵌套代码块的关闭花括号 } 处被自动调用析构函数 ~Tree()。
            - 
        2. 外部对象(Tree t;这句话定义的t)的解构：
            
            - 定义：Tree t;
            - 作用域：它的作用域是整个main函数
            - 析构时间：它将在main函数执行结束，即将退出时（即return 0之前）被自动调用析构函数~Tree()。
    
    !!! warning
        ```c++
            #include<iostream>
            using namespace std;
            
            class X{
            public:
                X();
            };
            
            X::X() {};
            
            void f (int i){
                if (i < 10){
                    goto jump1;
                }
                X x1;
                jump1:
                switch(i){
                case 1:
                    X x2;
                    break;
                case 2:
                    X x3;
                    break;
                }
            }
            int main(){
                f(9);
                f(10);
                return 0;
            }
        ```
        
        - 错误点一：由于 i=9 符合 i<10 这一条件，因此会跳过`X x1`这句话，但是当函数寿命到期的时候会对其进行解构，因此我们会结构一个未构建的变量，此时我在终端中企图编译这段代码就会出错。
        ![](附件/Pasted%20image%2020251022191241.png)
        - 错误点二：把`X x1`这句话注释掉之后这段代码仍有问题，我们跳到了case之后，程序并未进入到case1，而是直接进入了case 2，因此`X x2`这句话也被跳过了，但是函数达到生命期之后也会对x2进行解构，因此在终端中编译仍然失败。
        ![](附件/Pasted%20image%2020251022192454.png)
        - 解决方法：我们应该给这几个变量定义的语句再加一个{}，这样子的话，如果函数没有执行到这一语句，那么就不会进入到这个作用域，相应的在程序结束前也不会对其解构:
        ```c++
            X x1; //错误❌
            {X x1;} //正确✔
            
            X x2; //错误❌
            {X x2;} //正确✔
            
            X x3; //错误❌
            {X x3}; //正确✔
        ```
        


