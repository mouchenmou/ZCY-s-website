## Initializer list
```c++
    Class Point {
    private:
        const float x, y; // 成员变量是 const
    public:
        // 构造函数使用初始化列表
        Point(float xa, float ya) : y(ya), x(xa) {} // 初始化列表中 y 在 x 之前
};
```
在这个示例中，Point 类的成员 x 和 y 被声明为 const。这使得 **它们必须在对象构造时（即构造函数体执行之前）被初始化，而不能在构造函数体内赋值。**

### 初始化列表的关键特性

- Can initialize any type of data

    - 初始化列表可以用来初始化任何类型的成员数据。
    - pseudo-constructor calls for built-ins：对于内置类型（如 int, float），它执行的是类似构造函数的初始化行为。
    - No need to perform assignment within body of ctor：使用初始化列表是初始化，而不是赋值。它在构造函数体执行之前完成，因此效率更高，也是初始化 const 成员、引用成员和基类成员的唯一方法。

- Order of initialization is order of declaration

    - 初始化顺序由声明决定： 这是初始化列表最重要的规则。
    - Not the order in the initializer list!：在代码示例中，y(ya) 在 x(xa) 之前，但如果 x 在类定义中先声明，那么 x 会先于 y 初始化。
    - Destroyed in the reverse order.：成员的销毁顺序与它们的初始化顺序相反。因此先销毁 y 再销毁 x 。

### 总结
初始化列表是 C++ 中实现保证初始化 的推荐方式。它不仅是初始化 const 成员和引用成员的必需方式，也确保了成员按照声明顺序进行初始化，从而避免潜在的依赖错误。

!!! explanation "`: y(ya), x(xa) {} `是什么意思？"
    `: y(ya), x(xa) {} `是 C++ 构造函数的初始化列表 (Initializer List) 部分，用于在构造函数体执行之前，对类的成员进行初始化。
    
    ### 作用和语法：
    
    1. 冒号 (:)： 标志着构造函数头（参数列表）的结束和初始化列表的开始。
    2. y(ya), x(xa)： 这是初始化列表的内容。它的格式是 成员变量名(参数名)。
    
        - 它表示将构造函数参数 ya 的值用来初始化成员变量 y。
        - 将构造函数参数 xa 的值用来初始化成员变量 x。
        
    3. 花括号 ({})： 这是构造函数的函数体。在初始化列表完成后，才会执行花括号内部的代码。
    
    ### 为什么使用初始化列表？
    
    1. 保证初始化： 它是 C++ 官方推荐的初始化所有成员的方式。
    2. 必需性： 对于 const 成员（如您示例中的 x, y）和引用成员，它们在创建后不能被赋值，所以它们必须通过初始化列表进行初始化。
    3. 效率： 相比在花括号内使用 = 进行赋值，初始化列表是初始化（直接构建），而不是先默认构造再赋值，效率更高。

!!! explanation "为什么没有用分号 (;) 结尾？"
    在 C++ 中，分号 (;) 用于结束一个语句 (Statement)。而 Point(float xa, float ya) : y(ya), x(xa) {} 是一段函数（或构造函数）的定义，而不是一个普通的语句。
    
    - 函数定义结构： C++ 的函数和构造函数定义是由函数头和函数体组成的。
        
        - 函数头： Point(float xa, float ya)
        - 初始化列表： : y(ya), x(xa)
        - 函数体： {}
    - 规则： 函数的定义（提供函数体或花括号 {} 的完整实现）后面不加分号。
    - 对比： 只有函数声明（原型，即只告诉编译器函数签名，不提供函数体）时才需要分号，例如在头文件 .h 中: `Point(float xa, float ya);`但在` .cpp` 文件中（或在类定义中直接提供函数体时），完整的定义不需要分号。
    
    ### 总结：
    不能在类内部放一个函数声明后面跟着一个函数定义，C++ 编译器认为：
    
    - `Point(float xa, float ya);` $\rightarrow$ 这是一个 **声明** ，后面需要分号。
    - `Point(float xa, float ya) : y(ya), x(xa) {}` $\rightarrow$ 这是一个定义，因为它提供了实现（包括初始化列表和函数体），后面不需要分号。

---

## Function overloading
Same functions with different arguments list.

- 核心定义： 函数重载允许在同一个作用域内定义多个名称相同、但参数列表不同的函数。
- 参数列表不同意味着参数的数量不同，或者参数的类型不同，或者两者都不同。

下面就给出了五个定义在同一个作用域内的名为print的函数（方法），它们具有不同的参数列表：
```c++
    void print (char *str, int width); //两个参数: char*, int
    void print (double d, int width); //两个参数: double, int
    void print (long l, int width); //两个参数: long, int
    void print (int i, int width); //两个参数: int, int
    void print (char *str); //两个参数: char*
```
![](附件/Pasted%20image%2020251022151313.png)

---

## Overload and auto-cast
```c++
    void f(int i); // 接受int参数的函数
    void f(double d); // 接受double参数的函数
```
这里定义了两个同名的函数f， 它们通过参数类型的不同实现重载

![](附件/Pasted%20image%2020251022152513.png)

---

## Default arguments

1. A default argument is a value given in the declaration that the compiler automatically inserts if you don't provide a value in the function call.

    - 定义： 默认参数是在函数声明时赋予参数的一个值。
    - 作用： 如果在调用该函数时没有提供这个参数的值，编译器会自动将默认值插入到函数调用中。

```c++
    Stash(int size, int initQuantity = 0);
```

- 这是一个名为 Stash 的函数（很可能是一个构造函数），它接受两个 int 类型的参数。
- size：这个参数没有默认值，必须在调用时提供。
- initQuantity = 0：这是一个默认参数。它的默认值是 0。

!!! example "调用示例1"
    ```c++
        Stash(100, 5); //size被设置成100，initQuantity被设置成5
        
        Stash(100); //size被设置成100，initQuantity未提供，编译器自动插入默认值0
    ```

2. To define a function with an argument list, defaults must be added from right to left.

    - 核心规则： 在定义带参数列表的函数时，默认值必须从参数列表的最右侧参数开始添加。这意味着，一旦一个参数有了默认值，它左边的参数就必须是强制传入的，而它右边的所有参数也必须有默认值。
        - 从右向左： 在函数（或构造函数）的参数列表中，所有带有默认值的参数必须放在没有默认值的参数的右边。一旦一个参数被赋予了默认值，它右边的所有后续参数也必须有默认值。这意味着你不能定义 Stash(int size = 10, int initQuantity);，因为 initQuantity 在带有默认值的 size 的右边。
!!! example "调用示例2"
    ```c++
        int harpo (int n, int m = 4, int j = 5); //legal
        int chico (int n, int m = 6, int j); //illegal
        int groucho (int k = 1, int m = 2, int n = 3); //legal
        
        beeps = harpo (2); //n=1, m=4, j=5
        beeps = harpo (1, 8); //n=1, m=8, j=5
        beeps = harpo (8, 7, 6); //n=1, m=7, j=6
    ```

### 总结

默认参数是 C++ 函数重载（Overloading）的一种替代或补充方式，它简化了函数调用，允许在函数需要较少参数时使用更简洁的语法，同时保留了使用全部参数时的灵活性。如果这个 Stash 是一个构造函数，它允许在创建对象时提供更多的初始化便利。

---

## Constant objects

1. 什么是常量对象？
    - 示例： const Currency the_raise(42, 38);
    - 定义： 当一个对象使用 const 关键字声明时，它就成为一个常量对象。
    - 含义： const 意味着该对象的状态（即它的非静态成员变量/字段）在对象被创建后，不能被修改。

2. 常量对象带来的问题
    - What if an object is const?
        - 如果一个对象是 `const`，那么任何试图修改其内部状态（字段）的代码都将是**非法**的。
        
    - What member functions can access the internals?
        - 核心问题： 既然常量对象不能被修改，那么哪些成员函数可以被调用？
        - 答案（C++规则）： 只有那些被声明为 const 成员函数的方法才能被常量对象调用。
            - const 成员函数：承诺不会修改对象的状态。编译器会强制执行这个承诺。
            - 非 const 成员函数：被认为具有修改对象状态的潜力，因此不能被 const 对象调用。

### 总结

常量对象（如 the_raise）是 C++ 中实现不变性（Immutability）和契约的重要工具。通过将对象声明为 const，程序员向编译器保证该对象的状态将保持不变，这有助于代码安全性和多线程编程。只有那些明确承诺不会修改对象的成员函数（即 const 方法）才被允许在常量对象上操作。

!!! example
    ```c++
        #include<iostream>
        using namespace std;
        class Y{
            int m_i;
            public:
            Y (int i){ //接受一个i作为构造
                m_i = i;
                cout << "In construction " << endl;
            }
            Y (Y &next){ //接受一个Y作为构造
                m_i = next.m_i;
                cout << "In copy construction " << endl;
            }
        };
        class Myclass{
            int a;
            double b;
            Y m_y;
            public:
            Myclass(int x, double y, Y m): a(x), b(y), m_y(m){
                m_y = m;
                cout << a << " " << b << endl;
            }
            
            Myclass(int x, double y, int m): a(x), b(y), m_y(m){
                cout << a << " " << b << endl;
            }
        };
        
        int main(){
            char a[4];
            char *b = new char[4];
            
            cout << a << endl;
            cout << " " << endl;
            cout << b << endl;
            
            Myclass(3, 4, Y(1));
            Myclass(3, 5, 6);
            
            return 1;
        }
    ```
    ![](附件/Pasted%20image%2020251022210459.png)
        !!! explanation "为什么`in construction`后面会出现`in copy construction`
            首先我们需要明确 `Y (Y &y)` 与 `Y (Y y)` 的区别：
            ```c++
                void f1(Y x){}
                void f2(Y& x){}
                int main(){
                    Y x;
                    f1(x); //这一步操作等价于x1=x; f1(x1);进行完这两步操作之后还会进行x2=x1; f1(x2);以此类推就会发生无限递归。因此这道题目中的拷贝函数必须加上引用（&）。
                    f2(x); //因为待传递的参数是一个引用，因此传入之后这两个东西是同一个东西，这一步操作就等价于f2(x); 因此不会发生无限递归
                }
                
            ```
            