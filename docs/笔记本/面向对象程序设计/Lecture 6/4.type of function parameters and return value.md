## Way in
1. 值传递: `void f(Student i);`
    - 特点:
        - a new object is to be created in f（在函数 f 内部会创建一个新对象）
        - 调用函数时，原始对象 i 的一个 完整副本 会被创建并作为参数传递给函数。
    - 优缺点:
        - 优点: 函数内部对参数的任何修改都不会影响到原始对象（因为操作的是副本）。
        - 缺点: 对于 Student 这种用户自定义的、可能包含大量数据的类对象，复制对象会产生显著的性能开销（涉及调用拷贝构造函数）。
2. 指针传递: `void f(Student *p);`
    - 特点:
        - better with const if no intend to modify the object（如果不想修改对象，最好加上 const）
        - 传递的是原始对象在内存中的 地址（一个指针）。
    - 优缺点:
        - 优点: 避免了对象复制，性能开销小（只传递一个指针的大小）。
        - 缺点: 使用指针操作（-> 或 *）语法相对繁琐；函数内部可以通过指针修改原始对象，可能导致意外副作用。
    - 建议: 如果你不打算修改传入的对象，应该使用 const 关键字来保护原始数据，即：void f(const Student *p);
3. 引用传递: `void f(Student &i);`
    - 特点:
        - better with const if no intend to modify the object（如果不想修改对象，最好加上 const）
        - 传递的是原始对象的 别名（一个引用）。
    - 优缺点:
        - 优点: 高效且安全的首选方式。 同样避免了对象复制（性能高）；使用起来就像操作值本身一样简单（语法自然）。
        - 缺点: 默认情况下，函数内部可以修改原始对象。
    - 建议: 这通常是 C++ 中传递大型自定义对象时的 最佳实践。如果你不打算修改传入的对象，应该使用 const 关键字来保护原始数据，即：void f(const Student &i);

---

## Way out
1. 值返回: `Student f();`
    - 特点:
        - a new object is to be created at returning（在返回时会创建一个新对象）
        - 函数内部创建的或计算出的对象会通过 复制 机制传递给调用方。
    - 开销/优化:
        - 理论上: 返回时会发生一次对象复制（调用拷贝构造函数或移动构造函数）。这对于大型对象来说是性能开销。
        - 实际上: 现代 C++ 编译器通常会优化掉这次复制，直接在调用方预留的内存上构造对象，从而消除开销。因此，值返回常常是返回新创建对象的最安全和最常用的方式。
2. 指针返回: `Student* f();`
    - 特点:
        - what should it points to?（它应该指向什么？）
        - 函数返回一个指向 Student 对象的 指针。
    - 潜在问题（what should it points to? ）:
        - 问题 1：返回栈上变量的指针 (Error): 如果函数返回一个指向局部（栈上）对象的指针，当函数返回时，该局部变量的内存就被释放了。返回的指针将变成一个 悬空指针 (dangling pointer)，使用它会导致未定义行为。这是绝对禁止的。
        - 问题 2：返回堆上变量的指针 (OK, but need care): 函数可以在堆上动态分配一个对象 (new Student())，并返回其指针。
            - 注意: 这种方式将 所有权 (ownership) 传递给了调用方。调用方必须负责在适当时候使用 delete 来释放这个对象，否则会导致 内存泄漏 (memory leak)。通常建议返回智能指针（如 std::unique_ptr<Student>）而不是裸指针来管理所有权。
3. 引用返回: `Student& f();`
    - 特点:
        - what should it refers to?（它应该引用什么？）
        - 函数返回一个 Student 对象的 引用（别名）。
    - 潜在问题（what should it refers to? ）:
        - 问题 1：返回局部（栈上）变量的引用 (Error): 与指针返回类似，绝对禁止 返回函数内部创建的局部（栈上）对象的引用。函数结束后，该对象被销毁，返回的引用会成为一个悬空引用 (dangling reference)。
        - 问题 2：返回静态或全局变量的引用 (OK): 可以返回指向生命周期长于函数调用的对象（如全局变量、静态变量或作为函数参数传入的引用）的引用。
        - 问题 3：用于链式调用或访问器 (OK): 引用返回主要用于：
            - 实现操作符重载（如 operator=）。
            - 实现对象的链式调用（例如，`cout << a << b;`）。
            - 作为 getter 或 setter 成员函数，允许直接访问或修改对象的内部状态。

---

## hard decision
1. 函数`char *foo()`
```c++
    char *foo(){
        char *p;
        p = new char[10];           // 1. 在堆上分配内存
        strcpy(p, "something");     // 2. 写入数据
        return p;                   // 3. 返回裸指针
    }
```

- `foo()` 在堆上使用 `new char[10]` 分配了一块内存。
    
- 它返回一个指向这块内存的 **裸指针** `p`。

2. 函数`void bar()`
```c++
    void bar(){
        char *p = foo();            // 1. 接收指针（获得所有权）
        printf("%s", p);
        delete p;                   // 2. 释放内存
    }
```

- bar() 调用 foo() 接收了堆内存的地址。
- bar() 必须 使用 delete[] p;（因为 foo() 中使用了 new char[10]，这是一个数组分配，图片中误写为 delete p;，这是一个错误，可能导致未定义行为！）来释放内存。

### “艰难的决定”是关于 谁来负责释放内存

决策点 1：让用户承担责任 (Let user take resp., pass pointers in & out)
这是代码中实际采用的方案。

- 策略: foo() 函数负责 分配 内存并将其所有权传递给调用者 (bar())。调用者（即用户/客户端代码）必须负责 释放 这块内存。
- 优点: 简单直接，适用于 C 风格的 API。
- 缺点: 高风险。如果调用者忘记调用 delete[] p;（或调用了错误的 delete p;），就会导致 内存泄漏 (Memory Leak)。如果程序有多个退出路径或异常处理，确保释放将变得非常困难。

决策点 2：定义一对分配和释放函数 (define a pair functions of alloc and free)

- 策略: 为了缓解“用户忘记释放”的问题，API 设计者可以提供一对配套的函数。
- 例如：`char *my_alloc_string()` 和 `void my_free_string(char *p)`。
- 优点: 清晰地将内存管理责任集中在 API 中。用户只需调用配套的释放函数，而不需要知道底层使用了 new/delete 还是 C 语言的 malloc/free。
- 缺点: 仍然需要用户记住调用释放函数。

---

## Tips

#### A. 参数传递建议

|**建议**|**解释**|**对应的 C++ 签名示例**|
|---|---|---|
|**Pass in an object if you want to store it**|**值传递**。如果你打算将传入的对象复制一份并存储在类成员中（例如，通过移动语义来优化），或者该对象很小（如 `int`），可以使用值传递。|`void set_data(Data d);`|
|**Pass in a const pointer or reference if you want to get the values**|**常量引用或常量指针传递**。这是 **读取** 大型对象数据的标准方式。它避免了复制开销（高效），同时通过 `const` 保证了原始对象不会被修改（安全）。|`void print(const Student& s);`|
|**Pass in a pointer or reference if you want to do something to it**|**非常量引用或非常量指针传递**。如果你想在函数内部 **修改** 原始对象的状态，就必须使用非常量的引用或指针。|`void normalize(Vector& v);`|

---

#### B. 返回值建议

|**建议**|**解释**|**对应的 C++ 签名示例**|
|---|---|---|
|**Pass out an object if you create it in the function**|**值返回**。这是返回函数内部新创建对象的最安全、最简洁的方式。现代 C++ 编译器通过 **RVO/NRVO 优化**，通常会消除复制开销。|`Student create_default();`|
|**Pass out pointer or reference of the passed in only**|**返回已存在对象的引用或指针**。仅当你返回的对象是作为参数传入的对象（且其生命周期长于函数调用），或者返回的是全局/静态对象时，才应该使用引用或指针返回。这主要用于实现链式调用或访问器。|`Student& get_member();`|
|**Never new something and return the pointer**|**避免返回裸指针来传递所有权**。这是最重要的安全建议。在堆上 `new` 一个对象并返回裸指针给调用者，要求调用者必须手动 `delete`，这极易导致内存泄漏（如上一个图片“hard decision”所述）。|**错误示例:** `Student* create();` **✅ 推荐:** 使用智能指针 `std::unique_ptr<Student> create();`|