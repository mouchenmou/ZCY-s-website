## Overhead for a function call
### 1. 核心定义：
- The processing time required by a device prior to the function of a command（设备在执行命令之前所需的处理时间）
    
    - 在函数调用的上下文中，“命令”指的是函数体内发的实际代码执行。
    - “处理时间”指的是在进入函数体之前和从函数体返回之后，为了管理和维护执行上下文所需的时间。

### 2.函数调用开销的具体步骤
函数调用通常需要操作系统或运行时环境执行一系列标准的步骤来设置和清理执行环境，这些步骤构成了主要的开销：

- `Push parameters`（推送参数）：
    - 函数将调用所需的参数值按顺序推入到调用栈中。
- `Push return address`（推送返回地址）：
    - 将当前指令执行完成后，程序应该返回到哪里继续执行地址（即调用点之后的下一条指令地址）推入调用栈。这是函数执行完毕后能够正确返回的关键。
- `Prepare return values`（准备返回值）：
    - 函数执行结束时，将函数的返回值放在一个指定的位置（通常是寄存器或栈上的特定位置），以便调用者能够获取它。
- Pop all pushed（弹出所有推送的内容）：
    - 函数执行完毕，返回到调用点之后，需要清理调用栈。这包括：
        - 弹出（清理）之前推入的参数
        - 弹出返回地址（程序已经跳转到该地址，现在可以清理它）
        - 回复调用前的寄存器状态（如果函数改变了它们）。

### 总结
函数调用的开销就是指创建和销毁栈帧所需的时间。对于执行体很小的函数（比如只执行一次简单的加法），这些管理调用栈的开销可能会比函数执行本身的代码还要耗时。

这也是为什么c++提供了`inline`来建议编译器消除函数调用开销：将函数体直接替换到调用点，从而避免了上述所有堆栈的操作。

---
## Inline
```c++
    int f(int i){                 inline int f(int i){
        return i*2;                   return i*2;
    }                             }
    int main(){                   int main(){
        int a = 4;                    int a = 4;
        int b = f(a);                 int b = f(a);
    }                             }
```
### 左侧函数：
- 执行过程：当程序执行到`int b = f(a);`时，会产生函数调用开销。
    1. 将参数 a（值 $4$）推入栈。
    2. 将返回地址推入栈。
    3. 程序跳转到函数 f 的代码块执行 return i * 2;。
    4. 准备返回值（$8$）。
    5. 程序跳转回返回地址，清理栈。
- 特点：保证了函数体只有一份代码，但每次调用都有时间开销。

### 右侧函数：
- `inline`关键字作用：建议编译器在编译时，将`f(a)`的调用直接替换为`f`函数体内的代码。
- 编译器潜在执行过程：编译器可能会将`main`函数编译成类似于以下的代码：
```c++
    int main(){
        int a = 4;
        int b = a*2; //f(a)的调用被i*2的代码替换
    }
```
- 效果：
    - 消除了函数调用开销：避免了参数入栈、返回地址入栈、跳转和栈清理等操作，从而提升了执行速度。
    - 代价：如果函数体很大或多次被调用，会使最终生成的机器代码量增大，这可能导致程序体积变大，并可能降低指令缓存的效率。

### 总结`inline`关键字：
1. 目的是消除函数调用开销，提高程序运行速率
2. `inline`只是一个建议：编译器可以忽略这个建议。对于递归函数、过于复杂的函数或函数指针调用，编译器通常会拒绝内联。
3. 最佳实践： inline 关键字最适合用于函数体很小、执行很快的函数（如图片中的 return i * 2;），因为在这种情况下，函数调用本身的开销可能比函数执行体还要大。
4. 必要性： 如果一个 inline 函数在多个源文件（.cpp）中被调用，它的定义（包括函数体）必须放在头文件（.h）中，否则程序在链接时会找不到函数定义。这也是 inline 关键字的另一个作用：它允许在多个编译单元中存在同一个函数的定义，而不会产生重复定义错误。

---
## inline functions（内联函数）
- All inline function is expanded in place, like a preprocessor macro, so the overhead of the function call is eliminated.（内联函数是就地展开的，就像预处理器宏一样，这样函数调用的开销就被消除了。）

1. "expanded in place"
    
    - 当编译器决定内联一个函数时，它不会生成传统的函数调用代码（即跳转到函数地址、堆栈等操作等。）
    - 相反，编译器会把函数体的所有代码，直接复制并插入到每一个调用该函数的地方。
    
2. "like a preprocessor"
    
    - 预处理宏也是一种简单的文本替换。
    - 相同点：它们都能在编译阶段消除函数调用开销。
    - 不同点：`inline`函数再替换代码时，仍然是真正的c++函数，它会进行类型检查和作用域检查，并且可以处理参数的副作用。而宏只是简单的文本替换，可能会导致意想不到的错误和副作用。
3. "so the overhead of the function call is eliminated"
    
    - 这是使用`inline`的最终目的。如前面所解释的，传统的函数调用开销包括参数和返回地址的入栈、出栈、堆栈清理、程序跳转等。
    - 通过就地展开，这些额外的工作被完全避免，从而使程序执行得更快。
4. 内联函数的定义位置
    
    - The definition of an inline function should be put in a header file.（内联函数的定义可能不会在`.obj`文件中生成任何代码。）
        - 解释：当编译器成功地将内联函数的代码替换到调用点时，它就不再需要为该函数生成一个独立的、可以被调用到的汇编代码。因此内联函数的定义在目标文件(.obj)中可能不留下任何独立的函数代码。
        - 例外：如果编译器拒绝内联（例如函数太复杂或通过函数指针调用），或者在某些特殊情况下，编译器可能会选择生成一个独立的函数实例作为备用。
5. 链接与声明的特殊性
    
    - It is declaration rather than definition.（它是声明而不是定义）
        - 背景：c++中有“单一定义原则”，即任何非内联函数或变量的定义在一个程序中只能出现一次。
        - 内联函数的特殊性：内联函数是ODR的一个例外。由于内联函数的定义通常放在头文件中，它会被包含到多个`.cpp`文件中，这意味着在程序中会有多个内联函数的定义副本。
        - 这句话的含义：尽管代码看起来是完整的函数定义，但`inline`关键字允许这个定义在不同的编译单元中重复出现，并且链接器能够正确处理它们。从链接器的角度来看，这些重复的定义更像是一种特殊的声明，而不是会导致错误的重复定义。

### 总结：
这段文字是`inline`函数的权威定义：它是一种再保证类型安全的前提下，通过编译时的代码替换来消除函数调用开销的优化机制。它的使用要求开发者改变传统的函数定义习惯，将定义放到头文件中，以支持其在编译时的就地展开特性。

---
## Inline functions in header file
1. 为什么将定义放入头文件？
    - So you can put inline functions' body in header file. Then `#include` it when the function is needed.（因此你可以将内联函数体放在头文件中，然后在使用该函数的任何地方`#include`它。）
        - 解释：这是内联函数最核心的使用要求。为了让编译器能在每一个调用点进行代码替换，它需要看到完整的函数体。将函数体放在头文件中，通过`#include`机制，确保了每个编译单元（`.cpp`文件）都能获得并使用这个完整的定义来进行内联优化。
2. 关于重复定义的保障
    - Never be afraid of multi-definition of inline functions.（永远不用害怕内联函数的重复定义）
        - 背景：如前所述，c++的单一定义原则(ODR)通常禁止在程序中出现同一个函数的多个定义。
        - 内联函数的特殊性：`inline`关键字正是特许了这种重复定义。当一个函数被声明为`inline`时，即使它的定义出现在多个编译单元中（通过`#include`头文件），链接器也会智能地处理这些重复的定义，确保最终程序中只有一个逻辑实体。这消除了使用宏的常见风险。
3. 链接器的视角
    - Definition of inline functions are just declarations
        解释：从c++语言规则的链接角度来看，虽然你提供了完整的函数体（定义），但`inline`关键字使得这些定义在不同编译单元中是合法的，且不会与ODR冲突。这句话的意思是，编译器和链接器将这些重复出现的定义视为一种特殊的声明方式，而不是会导致重复定义的错误的实体，它侧重于强调`inline`关键字给予的链接特殊性。

### 总结
这段内容是关于内联函数最佳实践的总结：为了实现编译时的性能优化，必须将它们的完整定义放在头文件中，并且不用担心因此导致的重复定义问题，因为`inline`关键字已经解决了这个链接层面的冲突。

---
## Tradeoff of inline functions
1. 机器与代码大小的权衡（空间换时间）
    - Body of the called function is to be inserted into the caller.（被调用函数的函数体将被插入到调用者中）
        - 这是内联函数的核心机制--就地展开。
    - This may expand the code size（这可能会增大代码大小）
        - 如果一个内联函数被N个地方调用，它的代码就会被复制N次。如果函数体很大，最终的程序可执行文件体积就会显著增大（称为代码膨胀）。这是牺牲的“空间”。
    - But deduces the overhead of calling time.（但减少了调用时间开销。）
        - 通过消除函数所需要的堆栈操作、地址跳转等，程序在运行时执行得更快。这是获得的“时间”（速度）。
    - So it gains speed at the expenses of space.（因此，它以牺牲空间为代价来获得速度。）
2. 相较于c语言宏的优势
    - It is much better than macro in C. It checks the types of the parameters, and has no dangerous side effect.（它比c语言中的宏要好很多。它检查参数的类型，并且没有危险的副作用。）
        - 类型检查：宏是简单的文本替换，不进行类型检查。而内联函数是真正的c++函数，编译器会对参数进行严格的类型检查和转换，提供了更高的代码安全和可靠性。
        - 无危险副作用：宏常因为参数包含副作用（例如MAX(a++, b)）而导致代码逻辑错误，因为参数可能会被重复求值，内敛函数不会有这种问题，它只会对参数求值一次。

### 总结
内联函数是一种于性能优化的工具，其基本原理是以增加程序体积（代码空间）为代价来提高运行速度（）时间。同时，它是c++对宏的优化代替方案，提供了类型俺去那和可靠性，解决了宏的许多缺陷。

```c++
    #define unsafe(i) \ ((i)>=0?(i):-(i))     inline int safe (int i){
                                                  return i>0 ? i:-i;
    int f();                                  }
                                              int f();
    int main(){                               int main(){
        ans = unsafe(x++);                        ans = safe(x++);
        ans = unsafe(f());                        ans = safe(f());
    }                                         }
```