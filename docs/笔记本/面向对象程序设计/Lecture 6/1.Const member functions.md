- Const member functions can not modify their object.
    不能修改它们的对象时const成员函数的最基本的规则。一个被声明为const的成员函数承诺不会改变调用它的对象的任何数据成员。
    
    ```c++ 
    
        int Date::set_day(int d){
            day d; // ok, non-const so can modify
        }
    ```
    
	- Date::set_day(int d): 这是一个普通的（非const）成员函数
    - day d; : 允许。因为该函数不是const的，它可以修改对象的数据成员(这里是day)。这种函数通常用于修改对象状态。
    
    ```c++
        int Date::get_day() const{
            day++; //ERROR modifies data member
            set_day(12); //ERROR calls non_const member
            return day; //ok
        }
    ```
    
	- Date::get_day() const：这是一个 const 成员函数，const 关键字出现在函数参数列表之后。
    - day++;：错误 (ERROR)。因为 day 是对象的一个数据成员，而 day++ 试图修改它的值，这违反了 const 成员函数的承诺。
    - set_day(12);：错误 (ERROR)。const 成员函数只能调用其他 const 成员函数。因为 set_day 是一个非 const 成员函数（它可能会修改对象状态），所以在一个 const 函数中调用它是不允许的。
    - return day;：允许 (ok)。仅仅读取数据成员的值是允许的，因为它不会修改对象的状态。这种函数通常用于获取对象状态。
### 总结：
在一个const成员函数中：

1. 不能直接修改对象的非 `mutable` 数据成员。
2. 不能调用该对象的任何非 `const` 成员函数。

    这样设计是为了保证，当你通过一个const对象或一个const引用来调用一个函数，你可以确信该对象的内部状态不会改变。

---
## Const member function usage(Const member function usage)

### 1. 声明和定义中的 const 关键字：
- Repeat the const keyword in the definition as well as the declaration (在定义和声明中都要重复 const 关键字)
    
    - 声明
        ```c++
           int get_day() const;
        ```
    
	- 定义
	```c++
	    int get_day() const {return day;}
	```
	`const`关键字必须在定义时再次出现，以表明这个特定的函数实现是一个`const`版本的成员函数。如果定义中遗漏了`const`，编译器会将其视为一个普通的（非const）成员函数，这通常会导致连接错误或行为不一致。

### 2. 最佳实践和原则

- **Function members that do not modify data should be declared const** (不修改数据的成员函数应该声明为 `const`)： 这是 C++ 中的“常量正确性” 原则。任何只是读取对象数据而不改变其状态的成员函数都应该被声明为 `const`。这样做有以下几个好处：
    
    1. **意图清晰**：明确告诉使用者该函数是安全的，不会改变对象。
    2. **强制约束**：如果程序员意外地在 `const` 函数中写了修改数据的代码，编译器会报错。
    3. **支持 `const` 对象**：只有 `const` 成员函数才能被 `const` 对象调用。
        
- **const member functions are safe for const objects** (`const` 成员函数对于 `const` 对象是安全的)： 正如前面的图片所解释的，`const` 成员函数是唯一可以被 `const` 对象调用的函数类型。这是因为编译器保证了 `const` 成员函数不会改变对象的状态，因此通过 `const` 对象调用它们是合乎逻辑和安全的。

---
## Const objects
核心概念：
非 const 对象：可以修改。
const 对象：创建后不能修改（除了 mutable 成员）。

1. 非 `const` 对象示例
```c++
    Date when(1, 1, 2001); //not a const
    int day = when.get.day(); // OK
    when.set_day(13); //OK
```

- Date when(1,1,2001);：创建了一个普通的（非 const）Date 类的对象 when。
- int day = when.get_day();: 非 const 对象可以调用 const 成员函数（如 get_day()）和非 const 成员函数。
- when.set_day(13); // OK：允许。非 const 对象可以调用非 const 成员函数（如 set_day()）来修改其内部状态。

2. `const` 对象示例
```c++
    const Date birthday(12, 25, 1994);
    int day = birthday.get_day();
    birthday.set_day(14); //Error
```

- const Date birthday(12,25,1994);：创建了一个 const 对象 birthday。这意味着该对象的内部状态在创建后不应该被改变。
- int day = birthday.get_day(); // OK：允许。const 对象只能调用 const 成员函数。假设 get_day() 是被声明为 const 的（如上一个图所示），则调用它是安全的。
- birthday.set_day(14); // ERROR：错误 (ERROR)。const 对象不能调用非 const 成员函数。因为 set_day() 没有被声明为 const，编译器认为它可能会修改对象的状态，而这对于 const 对象是禁止的。

### 总结规则：
| **调用者**          | **被调用的成员函数**     | **结果**    | **解释**                            |
| ---------------- | ---------------- | --------- | --------------------------------- |
| **非 `const` 对象** | `const` 函数       | OK        | 允许调用。                             |
| **非 `const` 对象** | 非 `const` 函数     | OK        | 允许调用（修改状态）。                       |
| **`const` 对象**   | **`const` 函数**   | **OK**    | **只能**调用 `const` 函数（保证不修改状态）。     |
| **`const` 对象**   | **非 `const` 函数** | **ERROR** | **禁止**调用，因为非 `const` 函数可能会修改对象状态。 |

!!! explanation "为什么定义和声明函数的时候`const`放在后面，但是调用函数的时候`const`放在前面？"
    1. 定义和声明时 const 放在后面（如 int get_day() const;）：这里的 const 是修饰成员函数，表示该函数不会修改调用它的对象。
        
        作用对象：`*this` 指针（即函数所操作的对象）
        
        - 当 const 放在成员函数签名后面时，它修饰的是该成员函数隐含的 this 指针。
        
            - 对于一个普通的成员函数，其隐含的 this 类型是：Date* const（指向非 const 对象的 const 指针）。
            - 对于一个 const 成员函数，其隐含的 this 类型是：const Date* const（指向 const 对象的 const 指针）。
        由于 this 指针指向了 const 对象，因此在函数体内就不能通过 this 来修改对象的成员变量（除非是 mutable 成员）。
    
    2. 调用函数时 const 放在前面（如 const Date birthday;）：这里的 const 是修饰对象，表示该对象不能被修改。
        
        当 `const` 放在变量或对象类型前面时，它修饰的是变量或对象的值。这是一个更常见的用法，表示该变量或对象在其生命周期内不能被修改。

---
## Const in class
```c++
    class A {
        const int i;
    }
```

这段代码在类A中声明了一个名为i的数据成员，并且它被const关键字修饰，这意味着：
    1. i是一个常量数据成员
    2. 一旦一个A类型的对象被创建，其成员i的值就必须确定，并且在对象的声明周期内不能再被修改。

### 核心规则和解释：
- Has to be initializer list of the constructor (必须在构造函数的初始化列表中初始化)
    - 原因：const 变量必须在它们被创建的那一刻就获得一个初始值，并且之后不能被赋值
    - 构造函数的两种赋值方式：
        1. 赋值(Assignment)：在构造函数体内部使用等号（=）赋值。这本质上是先默认构造（或不初始化），然后再赋值。
        2. 初始化(Initialization)：在构造函数初始化列表中赋值，这保证了变量在创建时直接获得初始值。
    - 对const成员的影响：
        - const成员不能再构造函数体内使用赋值语句进行初始化，因为到那时它已经被创建了（而且没有初值），任何尝试赋值的行为都会被视为修改，而const变量不允许修改
        - 因此唯一的合法方式是在构造函数的初始化列表中对其进行初始化。

```c++
    class A{
    public: 
        const int i; // 声明为 const
        
        // 构造函数
        A (int initial_value) : i(initial_value{
            i = 10; //Error，此时赋值已经太晚了，必须在i初始化的时候就定值
        }
    };
    A obj(42); obj.i 的值被设置为42，之后不能改变
```

正确的做法A：
```c++
    class A {
    public:
        const int i;
        
        //构造函数
        A(int initial_value): i(initial_value){
            // 构造函数体现在为空，或者用于执行其它非const成员的逻辑
        }
    }
    int main(){
        A obj1(10);//obj1.i 的值是10，并且不能再被改变。
        A obj2(42);//obj2.i 的值是42，并且不能再被改变。
        return 0;
    }
```
### 构造函数的执行分为两个阶段：
1. 初始化阶段：在进入函数体{}之前。所有成员变量都会在这个阶段被初始化（无论是通过初始化列表，还是通过默认构造函数隐式初始化）。对于`const`成员，必须在这个阶段完成赋值。
    - `i(initial_value)`就是在这里确保了i在被创建时就获得了`initial_value`。

2. 赋值/执行阶段：在函数体{}内部。此时，所有成员变量都已经被初始化，如果在体内对它们赋值，实际上是执行了赋值操作，而不是初始化。

对于const成员， **只能进行初始化，不能进行赋值** ，因此必须使用初始化列表。

---
## Complied-time constants in classes
```c++
    class HasArray{
        const int size;
        int array[size]; //Error!
    };
```
- `const int size`: 声明了一个const成员变量size。
- int array[size]; //编译器会在这里报错。
    - 原因：`const int size`虽然是常量，但它是对象成员。这意味着每个 `HasArray` 对象都会有一个自己的副本，而且它的值直到运行时（在对象构造时，通过构造函数初始化列表）才能确定。
    - 然而，c++规定数组的大小必须是编译时就能确定的常量表达式。由于size不是编译时常量，所以不能用来定义数组的大小。
### 解决方案：
为了在类内部定义一个编译时常量，便于用数组大小等场景，传统c++提供了两种方法：

1. 使`const`值变为`static`：
    - `static const in size = 100;`:
        - `static`: 表明`size`是类的常量，不属于任何对象，整个类只有一个`size`副本。
        - `const`：表明`size`的值不能改变。
        - 对于这种 `static const` 的整数类型成员（如`int, char, enum`) , c++允许在类定义内部直接赋予初始值。
        - 结果：`size`现在是一个编译时常量，可以安全地用于定义数组大小。
    - **`static indicates only one per class（not one per object）`**: 强调了`static`的作用，它使得`size`成为一个类级别的常量，而不是对象级别的常量。
    
2. 使用匿名枚举技巧（Aonoymous enum hack）
    
- `enum {size = 100};`
    
    - 枚举(enum)的成员(即这里的`size`)在c++中是编译的常量。
    - 通过将`size`放在一个没有名字的`enum`中，可以创建一个在类范围内可见的编译时常量。
    - 结果：`size`是一个编译时常量，可以用于定义数组大小，且不需要在类外定义或占用存储空间（除非取地址）。
    
- `int array[size]; //此时就是合法的了`

!!! solution "在现代`c++`中，最推荐的做法是使用`static constexpr`"
    ```c++
        class HasArray {
            static constexpr int size = 100;
            int array[size]; //OK!
        };
    ```