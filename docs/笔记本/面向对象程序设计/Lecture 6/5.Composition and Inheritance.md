## Reusing the implementation
- **Composition: construct new object with existing objects**
    - **组合** 是指通过将一个或多个现有对象作为新对象（类）的成员变量来构建新对象。    
- **It is the relationship of _has-a_**
    - 组合体现了 **“拥有一个” (has-a)** 的关系。新对象是其成员对象的 **拥有者**。
![](附件/Pasted%20image%2020251029113701.png)

---

## Composition

- Objects can be used to build up other objects
    -  对象可以用来构建其他对象。
- Ways of inclusion（包含方式 ）
    - Fully (完全包含/值组合)
        - 实现： 将组件对象作为复合体的 值成员（直接的非指针/非引用成员）。
        - 特点： 复合体 完全拥有 组件。组件的生命周期与复合体一致：复合体创建时组件创建，复合体销毁时组件销毁。
        - 示例： Car 拥有 Engine (如上一张图)。
    - By reference (通过引用/指针包含)
        - 实现： 将组件对象作为复合体的引用成员或指针成员
        - 特点： 复合体 不一定完全拥有 组件。组件的生命周期可能由外部管理。
- Inclusion by reference allows sharing (通过引用包含允许共享)
    - 当使用 共享指针或裸指针/引用时，多个复合体对象可以引用/共享 同一个组件对象。
    - 示例： 两个 Department 对象可以共享同一个 Budget 对象。

!!! example "Address这个对象是如何通过组合许多其他对象构建起来的"
    - Employee has a Name
        - Name 可能是 std::string 或一个更复杂的 Name 类。
    - Employee has an Address
        - Address 应该是一个独立的类，包含街道、城市、邮编等。
    - Employee has a Health Plan
        - Health Plan 是一个独立的类，包含保险信息等。
    - Employee has a Salary History
        - Salary History 是一个类，它内部又组合了一个：
        - Collection of Raise objects：可能是一个 std::vector<Raise>，其中 Raise 是另一个对象。这展示了组合的递归性。
    - Employee has a Supervisor
        - Another Employee object!：这展示了 组合的递归性 和 自包含性。一个 Employee 对象通过 引用或指针 包含另一个 Employee 对象作为其主管。如果使用引用/指针，则允许多个员工共享同一个主管对象，避免了复制和循环所有权问题。

---

## composition in action
![](附件/Pasted%20image%2020251029121528.png)

```c++
    class HealthPlan { /* ... */ };
    class SalaryHistory { /* ... */ };

    class Employee {
    private:
        std::string name;
        std::string address;
        HealthPlan healthPlan;
    
        // 成员变量：用于组合关系 (has-a)
        std::vector<SalaryHistory> salaryHistories;
    
        // 指针成员：用于引用关系 (has-a supervisor)
        // Pointer to the supervisor. Can be nullptr if no supervisor.
        Employee* supervisor;
    
    public:
        // 构造函数：初始化成员变量
        Employee(const std::string& name, const std::string& address) 
            : name(name), address(address), supervisor(nullptr) {}
    
        // 方法：添加 SalaryHistory 记录
        void addSalaryHistory(const SalaryHistory& history) { 
            salaryHistories.push_back(history); 
        }
    
        // 方法：获取 SalaryHistory 集合
        // 注意：这里是值返回，会导致集合的复制
        std::vector<SalaryHistory> getSalaryHistories() const { 
        return salaryHistories; 
        }
    
        // 方法：设置 Supervisor
        void setSupervisor(Employee* sup) { 
            supervisor = sup; 
        }
    
        // 方法：获取 Supervisor
        Employee* getSupervisor() const { 
            return supervisor; 
        }
    
        // 析构函数
        ~Employee() {} 
    };
```

- **类定义:** 代码假设 `HealthPlan` 和 `SalaryHistory` 类已存在。
    
- **组合关系:** `name`, `address`, `healthPlan`, 和 `salaryHistories` 都是 **值组合**。
    
- **引用关系:** `supervisor` 是一个 **裸指针**，体现了 **引用组合**，表示 `Employee` **有一个** 主管，但**不负责**主管对象的内存释放。
    
- **构造函数:** 使用了初始化列表来设置初始值，并将 `supervisor` 初始化为 `nullptr`。

---

## Embedded objects

1. 嵌入式对象必须被初始化
    - All embedded objects must be initialized
        - 解释： 在 C++ 中，当你创建一个包含其他对象（即成员变量）的类对象时，这些成员对象必须在包含它们的对象（宿主对象）被完全构造之前完成初始化。
    - The default constructor is called if...（如果满足以下条件，将调用默认构造函数）
        - you don't supply the arguments, and there is a default constructor (or one can be built)
        - 解释： 如果你在构造宿主对象时没有明确指定成员的构造参数，并且该成员类有一个默认构造函数（即无参数构造函数，或者编译器可以自动生成一个），那么这个默认构造函数将被隐式调用来初始化该成员。
        - 问题： 如果成员类只有带参数的构造函数（没有默认构造函数），而你又没有提供参数，则编译会失败。
2. 构造函数初始化列表 (Initializer list on Constructor)
    - 解释： 这是在 C++ 中初始化成员变量的首选且推荐的方式。
    - any number of objects separated by commas（任意数量的对象，用逗号分隔）
    - is optional（是可选的）
        - 注意： 虽然语法上可选，但对于非基本类型（如类对象、引用、const 成员）来说，它通常是必需或强烈推荐的。
    - Provide arguments to sub-constructors（向子构造函数提供参数）
        - 关键： 初始化列表允许你直接调用成员对象的特定构造函数，向其传递所需的参数，从而完成“一步到位”的初始化。
3. 语法 (Syntax)
    - `Syntax: name ( args ) [ ':' init-list ] '{' ...}`
        - 这展示了 C++ 构造函数的一般语法：
            - name ( args )：构造函数的名称和参数列表。
            - [ ':' init-list ]：初始化列表 部分。它以冒号 : 开始，后面跟着要初始化的成员及其参数。
            - { ... }：构造函数体（在初始化列表执行后执行）。

🌟 初始化列表的重要性

效率: 对于自定义类对象，使用初始化列表是 初始化，而不在初始化列表中而在构造函数体内部赋值是先调用 默认构造函数 进行初始化，然后再调用 赋值操作符 进行赋值。初始化列表避免了多余的默认构造和赋值操作。

必需性: 对于 const 成员、引用成员 以及没有默认构造函数的类成员，你必须使用初始化列表进行初始化。

统一性: 即使对于基本类型和有默认构造函数的类，使用初始化列表也能保持代码风格的一致性。

!!! example
    #### 1. 类定义 (SavingsAccount 结构)
    ```c++
        class Person { /* ... */ };
        class Currency { /* ... */ };
    
        class SavingsAccount {
        public:
            // 构造函数：接受初始化账户所需的所有参数
            SavingsAccount(const char* name, const char* address, int cents);
    
            // 析构函数
            ~SavingsAccount(); 
    
            // 打印方法
            void print();
    
        private:
            // 嵌入式对象 (成员变量)，体现组合关系 (has-a)
            Person m_saver;      // 账户拥有一个人 (has-a Person)
            Currency m_balance;  // 账户拥有一个余额 (has-a Currency)
        };
    ```
    
    - SavingsAccount 组合了两个成员变量：m_saver (类型为 Person) 和 m_balance (类型为 Currency)。
    - SavingsAccount 的构造函数接受创建其成员对象所需的所有参数：name 和 address 用于构造 m_saver，cents 用于构造 m_balance。
    
    #### 2. 构造函数实现（重点：初始化列表）
    ```c++
        SavingsAccount::SavingsAccount(const char* name, const char* address, int cents): m_saver(name, address),  m_balance(0, cents)  {}
    ```
    - 通过初始化列表，m_saver 对象被直接使用 name 和 address 参数构造，m_balance 对象被直接使用 0（可能代表美元/主要单位）和 cents（次要单位）参数构造。
    - 这种方式避免了先调用成员的默认构造函数，然后再调用赋值操作符的低效过程。
    
    #### 3. 成员函数实现
    ```c++
        void SavingsAccount::print(){
        m_saver.print();   // 通过组合，调用内部 Person 对象的 print 方法
        m_balance.print(); // 通过组合，调用内部 Currency 对象的 print 方法
        }
    ```
    - 这个 print() 方法展示了 代码重用 的核心：SavingsAccount 不需要自己知道如何打印账户所有者和余额的细节，它只需要调用其嵌入式成员对象（m_saver 和 m_balance）已实现的 print() 方法即可。
    
    🌟 总结
    
    这个例子是关于 组合 (Composition) 和 初始化列表 的一个经典且规范的 C++ 示例：
    
    1. 组合: SavingsAccount 通过将 Person 和 Currency 作为私有成员，实现了 “SavingsAccount has-a Person” 和 “SavingsAccount has-a Currency” 的关系。
    2. 初始化列表: 构造函数使用初始化列表来高效、清晰地将外部参数传递给内部嵌入式对象的构造函数，确保了所有成员都在宿主对象构造之前正确初始化。

---

## Question

#### 1. 错误的构造函数写法

假设 Person 类有 `set_name` 和 `set_address` 方法，`Currency` 类有 `set_cents` 方法，有人可能尝试这样写构造函数：
```c++
    SavingsAccount::SavingsAccount(const char* name, const char* address, int cents){
    // 构造函数体内的赋值/调用设置器
        m_saver.set_name( name );
        m_saver.set_address( address );
        m_balance.set_cents( cents );
    }
```

#### 2. 问题的核心：隐式调用默认构造函数

- Default constructors would be called (默认构造函数将被调用)

解释：

    1. 在构造函数体 {} 执行之前：C++ 强制要求所有成员变量必须先被初始化。
    2. 缺少初始化列表：由于这段代码没有提供初始化列表 (: m_saver(...))，编译器会尝试在进入函数体之前，隐式地 调用 m_saver (Person) 和 m_balance (Currency) 的 默认构造函数。
    3. 进入函数体后：然后，程序才进入构造函数体，执行 set_name、set_address 等方法，对已经构造（并可能默认初始化）的对象进行 重新赋值。

#### 3. 这种写法的缺点

|**问题**|**描述**|**影响**|
|---|---|---|
|**效率低下 (Inefficiency)**|对于 `m_saver` 和 `m_balance` 两个自定义类对象，先调用默认构造函数是 **一次操作**，然后在函数体内调用设置器进行赋值又是 **多次操作**。这产生了不必要的对象构造和/或赋值开销。|性能下降，尤其对于大型对象。|
|**必需性错误 (Necessity Error)**|如果 `Person` 或 `Currency` 类 **没有默认构造函数**（例如，它们必须接受参数才能构造），则这段代码会在 **编译时失败**，因为它无法在进入构造函数体前完成 `m_saver` 和 `m_balance` 的初始化。|导致编译错误。|
|**无法初始化特殊成员**|如果 `m_saver` 或 `m_balance` 被声明为 **`const`** 成员或 **引用成员**，它们必须在初始化列表中初始化，在构造函数体内部进行赋值是无效的（或不可能的）。|导致编译错误。|

---

## Public vs. Private

1. 默认和推荐的做法：Private 嵌入

    - It is common to make embedded objects private:（通常将嵌入式对象设为私有）
    - they are part of the underlying implementation（它们是底层实现的一部分）
        - 解释: 组合对象（如 m_saver 或 m_balance）是 SavingsAccount 内部工作机制 的一部分。根据面向对象设计的 封装 (Encapsulation) 原则，用户（外部代码）不应该直接访问或依赖这些实现细节。
    - the new class only has part of the public interface of the old class（新类只拥有旧类（组件）公共接口的一部分）
        - 解释: 如果成员是 private 的，SavingsAccount 必须通过自己的 公有方法（如 get_saver_name() 或 deposit()）来调用组件的相应方法。这样，SavingsAccount 就能够 控制 哪些组件功能暴露给外部，实现了 接口隔离 和 信息隐藏。

2. 公有嵌入 (Public Embedding)：直接暴露组件接口
    - Can embed as a public object if you want to have the entire public interface of the sub-object available in the new object:（如果你想让子对象完整的公有接口在新对象中可用，可以将其作为公有对象嵌入）

!!! example
    ```c++
        class SavingsAccount{
        public:
            Person m_saver; 
        }; 
        SavingsAccount account;
        account.m_saver.set_name("Fred"); 
    ```

---

## Reusing the interface（重用接口）

Inheritance is to take the existing class, clone it, and then make the additions and the modifications to the clone.（继承是一种机制，允许你基于一个现有的、定义好的类（`Shape`）来创建新的类（`Circle`, `Square`, `Triangle`），新的类自动拥有旧类的功能，并且可以根据需要添加新的功能或修改旧类的某些功能。）

- “已有的类” 指的是图中的父类 (Superclass) Shape。
- “克隆它” 指的是子类（Circle, Square, Triangle）会自动获得父类 Shape 的所有公共方法和属性（例如 move(), getColor(), setColor()）。
- “添加” 指的是子类可以有自己特有的方法（图中没有展示，但这是可能的）。
- “修改” 指的是子类可以重写 (Override) 父类的方法，以实现自己独特的行为。例如，图中的 Circle、Square 和 Triangle 都重写了 draw() 和 erase() 方法，因为画一个圆、一个正方形或一个三角形的具体步骤是不同的。

![](附件/Pasted%20image%2020251029140212.png)

---

## Inheritance

1. **Language implementation technique**
    
    - 解释：这是一种语言实现技术。继承是面向对象编程语言（如 Java, C++, Python 等）内置的一种机制，用于在代码层面实现类之间的关系和功能复用。
        
2. **Also an important component of the OO design methodology**
    
    - 解释：它也是面向对象（OO）设计方法学**的一个重要组成部分。在软件设计阶段，继承常用于表达“是一种”（is-a）关系，例如“圆**是一种**形状”，是构建清晰、可维护的软件结构的关键。
        
3. **Allows sharing of design for**
    
    - 解释：允许共享设计，具体包括：
        
        - **Member data (成员数据/属性)：** 子类可以访问并继承父类的非私有成员变量（数据）。
            
        - **Member functions (成员函数/方法)：** 子类可以继承并使用父类的非私有方法。
            
        - **Interfaces (接口/结构)：** 子类继承了父类的整体结构和公共行为规范。
            
    - **核心作用：** 通过共享设计，大大提高了 **代码的复用性**。
        
4. **Key technology in C++**
    
    - 解释：它是C++ 语言中的一项关键技术。C++ 是最早推广和完善面向对象特性的语言之一，继承在其类体系和多态性的实现中占据核心地位。
    
5. **The ability to define the behavior or implementation of one class as a derived one of another base class**
    
    - 解释：继承是一种能力，允许将一个类的行为或实现定义为另一个基类的派生类。
    - 核心要素：
        - Base Class (基类/父类): 被继承的那个类（提供了基础功能）。
        - Derived Class (派生类/子类): 继承了基类功能的那个新类。
        - 行为或实现 (Behavior or Implementation): 指的是类中的方法（Method）和属性（Field）。子类会复用父类的这些定义。

![](附件/Pasted%20image%2020251029143117.png)

---

## DoMe

DoME 是一个应用程序（application），允许我们存储有关  CD 和 DVD 的信息。
    -这表明DoME是一个媒体库或收藏管理系统
    
- 主要功能 1：数据录入
    
    - 我们可以输入关于 CD 和 DVD 的信息。
    - 这意味着用户需要手动或通过某种方式将收藏的媒体信息（如名称、艺术家/导演、发行年份等）添加到系统中。
    
- 主要功能 2：数据搜索
    
    - 我们可以进行搜索，例如：
        
        - 搜索数据库中某个特定艺术家的所有 CD。
        - 搜索数据库中某个指定导演的所有 DVD。
        
    - 这表明 DoME 具有基于特定元数据（如艺术家、导演）进行筛选和查找的高级搜索功能。

### 总结
DoME 是一个用于管理个人或小型媒体收藏（CD 和 DVD）的数据库应用，它提供录入和基于关键信息的搜索功能。

!!! concept "CD"
    1. the title of the album
        - 专辑标题/名称。
    2. the artist (name of the band or singer)
        - 艺人（乐队名称或歌手名称）。
    3. the number of tracks on the CD
        - CD 上的音轨（歌曲）数量。
    4. the total playing time
        - 总播放时长。
    5. a 'got it' flag that indicates whether I own a copy of this CD
        - 一个 “已拥有” 标志（通常是一个布尔值，True 或 False），用来指示我是否拥有这张 CD 的副本。
        - 这个标志对于收藏管理系统非常实用。
    6. and a comment (some arbitrary text)
        - 以及一个评论/备注（任意文本）。
        - 用于记录个人笔记、购买地点、状态等额外信息。

!!! concept "DVD"
    1. the title of the DVD
        - DVD 的标题/名称（通常是电影或节目的名称）。
    2. the name of the director
        - 导演的姓名。
    3. the playing time (we define this as the playing time of the main feature)
        - 播放时长（这里特别定义为主要内容/正片的播放时长）。
        - 排除了花絮、菜单等额外内容的时长。
    4. a 'got it' flag that indicates whether I own a copy of this DVD
        - 一个 “已拥有” 标志（布尔值），用来指示我是否拥有这张 DVD 的副本。
        - 这与 CD 的信息项保持一致，便于收藏管理。
    5. and a comment (some arbitrary text)
        - 以及一个评论/备注（任意文本）。
        - 用于记录个人笔记、购买信息等。

!!! example "The DoME example"
    1. DoME 的全称和核心功能：
        - "Database of Multimedia Entertainment"
        - 解释： DoME 的全称是“多媒体娱乐数据库”，明确了其作为数据库和媒体管理工具的定位。
    2. 存储的细节（数据结构总结）：
        - stores details about CD and DVDs
        - 解释： 它存储了关于 CD 和 DVD 的详细信息。
        - CD 信息： title (标题), artist (艺人), #tracks (音轨数), playing time (播放时长), got-it (已拥有标记), comment (备注)。
        - DVD 信息： title (标题), director (导演), playing time (播放时长), got-it (已拥有标记), comment (备注)。
    3. allows (later) to search for information or print lists
        - 解释： （在后续版本或设计中）它将允许搜索信息或打印列表。

---

## Class diagram
![](附件/Pasted%20image%2020251029150850.png)

## DeME classes
![](附件/Pasted%20image%2020251029151028.png)

## Object Model
![](附件/Pasted%20image%2020251029151204.png)

## Source code
![](附件/Pasted%20image%2020251029151318.png)

---

## Critique of DoME
### 核心问题是：**代码重复**

1. CD 和 DVD 类的高度相似性：
    - CD and DVD classes very similar (large part are identical)
        - 解释： CD 和 DVD 这两个类非常相似（大部分是相同的）。
        - 正如我们在前几页看到的，它们共享了 title, playing time, got-it, comment 等属性。如果将这些属性分别写在两个独立类中，就会造成代码冗余。
2. 代码重复导致维护困难：
    - makes maintenance difficult/more work
        - 解释： 这使得维护变得困难/工作量增加。
        - 例如，如果决定将 comment 属性从 String 改为支持多语言的结构，你需要同时修改 CD 类和 DVD 类，而不是只修改一个地方。
3. 代码重复引入 Bug 风险：
    - introduces danger of bugs through incorrect maintenance
        - 解释： 通过不正确的维护，引入了错误的风险。
        - 例如，如果维护人员只更新了 CD 类的 comment 属性，而忘记更新 DVD 类的同一属性，就会导致两个类行为不一致，引入难以发现的 Bug。
4. 数据库类中也存在代码重复：
    - code duplication also in Database class
        - 解释： 代码重复也存在于 Database 类中。
        - 如果 Database 类需要分别写 addCD(cd) 和 addDVD(dvd) 方法，以及分别写 searchCDs(...) 和 searchDVDs(...) 方法，那么这些方法内部的逻辑很可能会有大量重复，因为它处理的媒体项有许多共同的属性和操作。

## Discussion

1. The CD and DVD classes are very similar. In fact, the majority of the classes' source code is identical, with only a few differences
    -  CD 和 DVD 类非常相似。事实上，这两个类的大部分源代码是相同的，只有少数区别。
    - 这是对“代码重复”问题的详细描述，为引入抽象和继承做铺垫。
    
2. In the Database class. We can see that everything in that class is done twice – once for CDs and once for DVDs
    - 在 Database 类中，我们可以看到所有操作都做了两次——一次针对 CD，一次针对 DVD。
    - 例如，添加、搜索、删除等操作都需要为两种媒体类型分别编写一套几乎相同的代码。

!!! tips "What if we add new types of media?"
    
    ### Solution-Inheritance
    
    1.  **定义一个父类（Superclass）：**
        - **define one superclass : Item**    
        - **翻译/解释：** 定义一个**父类（Superclass）**，命名为 **`Item`**（项目/条目）。
        - _`Item` 将作为所有媒体收藏品（如 CD 和 DVD）的通用表示。_
    2. **定义子类（Subclasses）：**
        - **define subclasses for DVD and CD**
        - **翻译/解释：** 为 DVD 和 CD 定义**子类（Subclasses）**。
        - _即 `DVD` 和 `CD` 类将不再是独立的类，而是 `Item` 的子类。_
    3.  **父类定义共同属性：**
        - **the superclass defines common attributes**
        - **翻译/解释：** **父类**（`Item`）定义**共同的属性**。
        - _这些属性包括 `title`、`playing time`、`got-it`、`comment` 等。_
    4.  **子类继承父类属性：**
        - **the subclasses inherit the superclass attributes**
        - **翻译/解释：** **子类**（`CD` 和 `DVD`）**继承**父类（`Item`）的属性。
        - _这意味着子类不需要重复定义这些共同的属性。_
    5. **子类添加自己的属性：**
        - **the subclasses add own attributes** 
        - **翻译/解释：** **子类**添加**自己的**特有属性。
        - _`CD` 子类会添加独特的属性，如 `artist` 和 `tracks`；`DVD` 子类会添加独特的属性，如 `director`。
            
    ### 总结
        
    通过引入继承，将重复的代码和数据结构向上提取到 Item 父类中，这样不仅消除了代码重复，使系统更易于维护，而且通过定义一个通用的 Item 类型，也为Database 类提供了使用多态性来统一处理所有媒体项的基础。
    ![](附件/Pasted%20image%2020251029153108.png)


