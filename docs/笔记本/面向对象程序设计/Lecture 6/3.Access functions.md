- They are small functions that allow you to read or change part of the state of an object -that is, an internal variable or variables.（它们是允许你读取或改变对象部分状态的小函数--也就是说，改变一个或多个内部变量。）
    - 作用：它们是外部世界与对象内部状态（即私有数据成员）进行交互的受控通道。
    - 目的：实现面向对象编程的封装原则。通过将数据成员设为私有，外部代码不能直接访问，只能通过这些公共的访问函数进行操作，从而更好地控制数据的有效性和一致性。
```c++
    class Cup{
        int color;
    public:
        int getColor(){
            return color;
        }
        void setColor(int color){
            this -> color = color;
        }
    };
```

1. 读取数据的函数：Getter
```c++
    int getColor(){
        return color;
    }
```
- 作用：允许外部代码读取对象内部数据成员的值。
- 命名习惯：通常以`get`开头（如getColor）。
- 最佳实践（补充）：这种函数通常应该被声明为`const`成员函数，因为它只是读取数据，不改变对象状态。
```c++
    int getColor() const{
        return color;
    }
```

2. 修改数据的函数：Setter
```c++
    void setColor(int color){
        this -> color = color;
    }
```
- 作用：允许外部代码修改对象内部数据成员的值。
- 命名习惯：通常以`set`开头（如`setColor`）。
- 优势：在函数体内（例如`setColor`内部），你可以添加错误检查或逻辑验证代码，确保传入的值是有效的，从而保护对象的数据完整性。

### 总结
访问函数是实现封装的基础。它们将类的内部数据（如示例中的`color`）隐藏起来（默认为`private`），并通过公共接口（`public`函数）来控制对这些数据的访问和修改，从而使得类更容易维护和使用。

---

## Reducing clutter（减少冗余）
### 核心观点：保持接口简洁的原则

- Member functions defined within classes use the Latin in situ (in place) and maintains that all definitioins should be placed outside the class to keep the interface clean. (在类内定义的成员函数使用了拉丁语in situ（就地），并且主张所有定义应该放在类外以保持接口清晰。)
1. Member functions defined within classes. (在类内定义的成员函数)
在c++中，如果你在类定义中直接提供成员函数的实现（函数体），就像前面的`getColor()`和`setColor()`示例那样。

```c++
    class Cup{
    public:
        int getColor(){
            return color;//函数体直接在类定义内
        }
    };
```

- 隐含的特性：在c++早期标准中，任何在类定义内定义的成员函数都会被编译器自动视为`inline`候选函数（即具备`inline`属性）。这就是图片中提到的`in situ`（就地/在原位）的含义：函数被内联展开。

2. "To keep the interface clean"（以保持接口清晰）
    - 问题：如果你把所有的成员函数（特别是那些逻辑复杂的函数）的完整定义都放在类定义内部，类定义会变得非常长，充斥则实现细节，难以阅读。
    - 最佳实践： 为了保持头文件（通常包含类定义）的简洁和清晰，C++ 推荐只在类定义中提供函数声明，而将函数定义（实现）放在类定义之外，通常是在单独的 .cpp 源文件中。
3. 权衡和例外
    - **简洁优先：** 对于复杂的函数，将实现放在 `.cpp` 文件中（类外定义），使得类定义（接口）清晰。
    - **性能优先：** 对于非常短小的访问函数（Getter/Setter）或逻辑简单的函数，通常会打破这个“放在类外”的原则，直接在类内定义，目的是利用它带来的自动 `inline` 属性来消除函数调用开销。

### 总结
将类的接口（声明）与其实现（定义）分开。虽然在类内定义函数可以获得性能上的优势（自动 `inline`），但为了代码的可读性和可维护性，对于复杂的函数，应将定义放在类外。对于**短小的访问函数**，通常是保持在类内的少数例外，因为它们带来的 `inline` 性能优势大于对接口清晰度的轻微影响。

---

## Inline or not ?

1. 建议内联 (Inline):
    - 内联的目的是消除函数调用开销，因此适用于那些开销影响较大的函数：
        - Small functions, 2 or 3 lines (短小的函数，两三行)：
            - 对于执行速度极快的短函数，函数调用所需的开销（堆栈操作、地址跳转）可能远大于函数体执行本身的时间。内联能显著消除这些开销。
        - Frequently called functions, e.g. inside loops (频繁调用的函数，例如在循环内部)：
            - 如果一个函数在循环中被调用成千上万次，累积的调用开销会很大。内联可以一次性消除所有这些重复的开销，带来巨大的性能提升。

2. 建议不内联 (Not inline):
    - 不内联是为了避免代码膨胀和一些机制上的限制：
        - Very large functions, say, more than 20 lines (非常大的函数，例如超过 20 行)：
            - 如果函数体很大，将其代码复制到每个调用点（内联）会导致最终程序体积急剧增大（代码膨胀）。这可能导致指令缓存（Instruction Cache）效率降低，反而使程序变慢。
        - Recursive functions (递归函数)：
            - 编译器无法在编译时确定递归函数会调用自己多少次，因此无法进行真正的“就地展开”。如果对递归函数使用 inline，编译器通常会忽略这个建议，将其作为普通函数处理。

## 总结
最佳实践是将 `inline` 留给短小且频繁调用的函数，以获得性能提升，同时避免因内联大型或复杂函数而带来的代码膨胀和效率损失。

---
## Inline may not in-line1
- The compiler does not have to honor your request to make a function inline. It might decide the function is too large or notice that it calls itself (recursion is not allowed or indeed possible for inline functions), or the feature might not be implemented for your particular compiler.

**核心解释** ：inline 关键字只是一个建议，而不是强制命令。

- 编译器是老大（Compiler Discretion）：
    - C++ 标准明确规定，inline 关键字仅仅是对编译器的优化建议 (The compiler does not have to honor your request)。编译器可以根据它内部的优化算法和判断，决定是否要将函数进行内联展开。
- 编译器拒绝内联的主要原因：
    1. 函数太大：内联大函数会导致程序体积过度膨胀（代码膨胀），这可能降低指令缓存的效率，反而使程序变慢。在这种情况下，编译器会忽略 inline 建议，以避免性能倒退。
    2. 递归：递归函数在编译时不知道会调用自己多少次，无法进行完全的就地展开。因此，编译器不会对递归函数进行内联。
    3. 技术限制：在某些特定或旧的编译器中，或者在特定的编译选项下，编译器可能选择不实现或不执行内联优化。

### 总结
当我们在函数前加上 `inline` 时，我们是在表达一种 **优化意愿** ，但最终的决定权始终在编译器手中。

---

## Inline may not in-line2
- Nowadays, the keyword _inline_ for functions comes to mean "multiple definitions are permitted" rather than "inlining is preferred".

#### 1. 字面含义：内联是首选的

- 最初，inline 关键字是程序员给编译器的一个建议，告诉编译器“请尽量将这个函数的代码直接插入到所有调用它的地方，而不是进行常规的函数调用（压栈、跳转等）。”
- 好处：消除函数调用的开销，提高程序执行速度。
- 问题：这只是一个建议。现代编译器非常智能，它们会根据优化级别、函数大小、调用频率等因素，自己决定是否真正进行内联。编译器拥有最终决定权。

#### 2.实际含义：允许多重定义
- 由于编译器经常会忽略或自行决定是否内联，inline 关键字在 C++ 中更多地承载了一个技术性的角色，即处理 ODR (One Definition Rule，单一定义规则)。
- ODR 要求在整个程序中，每个函数或变量都只能有一个定义。
- 问题：当你在头文件中定义一个函数时（比如一个小的成员函数），如果这个头文件被多个 .cpp 文件包含，那么这个函数就会在链接阶段导致 “多重定义” (Multiple Definitions) 错误，因为它在每个 .cpp 文件中都有一个定义。
- inline 的作用：当你用 inline 关键字修饰一个函数时，它告诉链接器：“这个函数可以在多个编译单元（.cpp 文件）中拥有定义。这不是一个错误。它们都是同一个函数，链接器请自行处理（例如选择其中一个定义，或将它们合并）。”
- 结果：这允许程序员在头文件中定义函数（通常是为了让编译器能够更容易地进行内联优化，虽然不保证），而不会违反 ODR 导致链接错误。