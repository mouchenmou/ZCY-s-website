# const我在第一节的笔记中就有过描述，此处详解
- declare a variable to have a constant value（定义之后这个变量永远不变）
- constants are like variables
    - Observe scoping rules（遵守作用域规则）
        - 定义在一个大括号内部的话，外部就没法访问。
    - Declared with "const" type modifier（用const类型的修饰符来声明）
- A const in c++ defaults to internal linkage（c++中的const默认为内部连接）
    - 内联变量就是说我已经知道你这个变量是什么东西了，我为了加速执行，我就不在存储空间里面再去创建一个空间来存放这个东西了，我直接把你这段话当成一个指令
    - extern可以强制将这个变量弄成内存分配的形式
        ```c++
            const int bufsize = 1024; 
            此处的bufsize只有当前的cpp可以访问到，声明时必须初始化。
        
            extern const int bufsize = 1024;
            extern const int buffersize;
            使用extern时可以初始化也可以不初始化。
            但是，不进行初始化的前提是这个变量已经在别的文件中被初始化过了，
            你在当前的文件中把它引用过来了而已。并且这个引用过来的变量在它
            自己的文件中必须用extern const来定义，不然别的文件访问不到。
        ```

---

# Run-time constants
- const value can be exploited（const值可以被利用）
    ```c++
        const int class_size = 12;
        int finalGrade[class_size]; //这样是合法的
        
        int x;
        cin >> x;
        const int size = x;
        double classAverage[size]; //以前的编译器做不到，现在可以
    ```

---

# Aggregates
- 可以对聚合类型（aggregate）使用 `const`，但是编译器仍然会为它分配内存。
- 在这种情况下，const 的意思是“这块内存不可修改”。而不是“这是一个编译期常量。
    - 这块内存存在。
    - 你不能修改它。
    - 但编译器不会把它当成“常量表达式”来计算。
- 然而，这个值不能在编译期使用，因为编译器没有义务在编译时就知道那块内存的内容是什么。
```c++
    const int i[] = {1, 2, 3, 4};
    float f[i[3]]; //这是不合法的
    编译器不会往下一个个去找这个值
    
    struct S {
        int i,j;
    };
    const S s[] = {{1, 2}, {3, 4}};
    double d[s[1].j]; //这也是不合法的
    对于这个聚合类的数组来说，s[1]只是一个地址，
    编译器不会再去进一步解析这个东西，只有在运行
    的时候才会去进一步解析
```

---
# Pointers and const
- **常量指针（`const` 在 `*` 后面）**：指针本身可以改变，但它 **指向的值** 不能改变。
```c++
    int x = 5;
    const int* p = &x; // p指向的值是const的
    *p = 10;           // 错误！不能通过p修改x的值
    int y = 6;
    p = &y;            // 正确！p可以指向另一个变量
```

- **指针常量（`const` 在 `*` 前面）**： **指针本身** 不能改变，但它指向的值可以改变。
```c++
    int x = 5;
    int* const p = &x; // p本身是const的
    *p = 10;           // 正确！可以通过p修改x的值
    int y = 6;
    p = &y;            // 错误！不能让p指向另一个变量
```

- **都修饰（两个 `const`）**：指针本身和它指向的值都不能改变。
```c++
    int x = 5;
    const int* const p = &x; // 指针p和它指向的值都不能变
    *p = 10;                 // 错误！
    int y = 6;
    p = &y;                  // 错误！
```
---

# Quiz: What are these?
!!! example "Question1"
    ```c++
        string s("Fred");
        const string* p = &s; //不能通过指针去修改这个字符，但是可以修改指针本身
    
        string const* p = &s; //跟上面那条等价
    
        string *const p = &s; //不能修改指针本身，但是可以修改指针指向的值
    ```

!!! example "Question2"
    ![](附件/Pasted%20image%2020251005010836.png)
    首先我们需要明确的是各个变量的逻辑必须相符合。
    我们看到ip不是const类型的指针，因此它的值指向的值是可以改变的。
    但是ci是const类型的int，它是没法被改变的。因此让ip指向ci是不符合逻辑的。
    