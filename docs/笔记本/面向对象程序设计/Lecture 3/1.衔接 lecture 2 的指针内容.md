```c++
    #Include<iostream>
    #include<memory>
    using namespace std;
    struct cust{
        int p;
        // 在c++中可以给structure定义一个函数，写法跟类的构造函数是一样的，后面会讲到
        cust(int q = 0) // 对q初始化，如果我们不给它传参的话，它的默认参数就是0
            : p(q) //用p的值对q进行初始化
        {
            cout << "call construct " << p << endl; //在这个构造的函数中打印p的值
        }
        ~cust(){
            cout << "call destructor " << p << endl;//解构函数打印p的值
        }
    };
    int main(){
        cust *x = nullptr;
        int* p = new int(25);
        float* q = new float(75.25);
        
        cust* var1 = new cust(); //没有传参的话那就默认参数是0（因为自定义的默认参数是0）
        cust* var2 = new cust(25); //传参了那么默认的参数就是25
        cout << *p << " " << *q << " " << var1->p << " " << var2->p << endl;
        
        //delete
        delete p;
        delete q;
        delete var1;
        delete var2;
        //解构之后虽然把指针指向的内存给释放掉了，但是指针的地址还是保留着的，所以就变成了野指针
        
        cout << *p << " " << *q << " " << var1->p << " "<< var2->p << endl;
        
        p=nullptr;
        q=nullptr;
        var1=nullptr;
        var2=nullptr;
        
        return 0;
    }
```

!!! tips
    ![](附件/Pasted%20image%2020251004141721.png)
    上图是执行完这段代码之后的输出结果。由于对这四个指针解构了之后只是把它们指向的内存给释放了，并没有改变指针地址的值，因此它们变成了野指针。但是我的操作系统出了点问题导致这个q被重置之后输出的还是75.25