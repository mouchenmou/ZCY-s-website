# Reference are a new data type in C++

```c++
    char c; // a character
    
    char* p = &c; // a pointer to a character
    
    char& r = c; // a reference to a character
```

!!! tips
    在 C++ 中，**引用（reference）** 就是某个变量的**别名**。  换句话说，**引用就是对一个已有变量的另一个名字**。
    例如：
        ```c++
            int main(){
                int a = 10;
                int& b = a; //b是a的引用
                b = 20;
                cout << a << endll; //输出的是20
            }
        ```
        - a是一个int类型的变量
        - b是a的引用
        - 从此以后，a和b 是同一个内存位置的不同名字

---

# Local or global variables
```c++
    type& refname = name; //引用的定义方式
    创建引用的时候要直接初始化，也就是必须把等号右边的东西也写上，这点与指针不同。
```

```c++
    以下为实现过程：
    int x = 12;
    int& y = x;
    y = 20;
    cout << x << endl; //输出结果为20
```

---

# In parameter lists(函数) and member variables
```c++
    type& refname
    Binding defined by caller or constructor（调用时进行初始化）
```

!!! tips "作为函数参数"
    如果想让函数修改外部变量，可以使用引用：
        ```c++
            void swap(int& a, int& b){
                int temp = a;
                a = b;
                b = temp;
            }
            调用时：
            int x = 1, y = 2;
            swap (x, y);
            cout << x << " " << y; //输出结果为2 1
        ```
        其实这个swap函数也可以写成void swap(int a, int b)，并且函数内部的代码完全不用变，二者的效果相同但是有本质区别。当使用引用时，a与b的初始化发生在swap(x, y)这一刻，相当于是a成为了x的别名，b成为了y的别名，所以改变了a就改变了x，改变了b就改变了y。


!!! tips "Q and A"
    Q:那我要是对这个函数进行多次调用，比如说第一次是swap(x,y)，第二次是swap(z,j)，那我第二次调用的时候，岂不是使得a，x，z三者都是一体的，我在改变z的时候同样也改变了x，这样不是会很不好吗?
    
    A:每一次函数调用，都会产生一套全新的 a、b，它们之间完全隔离。
    当我们写下以下代码时：
        ```c++
            int x=1, y=2, z=3, j=4;
            swap(x, y); //第一次调用
            swap(z, j); //第二次调用
        ```
    计算机的执行过程是这样的：
    ![](附件/Pasted%20image%2020251004153652.png)
    ![](附件/Pasted%20image%2020251004153715.png)

---

# Rules of references
- Bindings don't change at run time, unlike pointer
    reference一旦初始化之后是没法在runtime的时候去修改的
- Assignment changes the object referred-to
    ```c++
     int& y = x;
     y = 12; // Changes value of x
    ```
- The target of a reference must have a location
    ```c++
        下面这种写法是错误的！！！
        void func(int &); //这句话是合法的，它表示接受一个int类型的引用作为参数函数
        func (i*3); //这句话是不合法的，引用的时候一定要有一个具体的变量，i是一个变量，但是i*3是一个表达式的结果，是一个临时的计算结果，没有实际的内存地址
    ```

---

# Pointers vs. References
![](附件/Pasted%20image%2020251005010903.png)

---

# Restrictions
- No references to references
- No pointers to references
    ```c++
        int&* p; //这是不合法的
    ```
!!! explanation
    - 引用是别名，直接绑定到某个变量
    - 指针则是存储一个内存地址的变量，指向另一个对象
    但是引用本身并不占内存空间，它只是某个对象的别名。因此，没有意义去定义一个指向引用的指针，我们无法指向一个没有单独内存的地址。下面举个例子来解释一下：
        ```c++
            int& b = a; //引用只是给原有的变量一个别名，并不是产生一个新的变量
            - 上面这段代码给原有的变量a取了一个别名b，编译器在编译阶段遇到b时都会将其替换成a
            - b自己没有独立的内存，编译器并不会给它分配内存
            
            下面我们将b替换为*p：
            int&* p = a; //此处相当于是用*p把b给等效替换了
            - 刚刚我说过编译器并不会给b分配内存，相同的，此处也不会给p分配内存
            - 但是p是个指针，它必须有内存，这就跟编译器没有给p分配内存矛盾了，因此不成立
        ```
- Reference to pointer is ok
    ```c++
        void f (int *& p); //这是合法的
    ```
!!! explanation
    - 引用本质上时一个别名，它可以绑定一个指针
	- 在这个例子中`int*& p` 表示 `p` 是一个指向 `int` 的引用，而且这个引用本身绑定到一个指针上。
	- 当传递指针时，`int*& p` 允许你修改指针本身，而不仅仅是指针指向的内容。
	下面来举个例子加深理解（上面的解释是gpt给出的，不太好理解）
	    ```c++
	        #include<iostream>
	        using namespace std;
	        void f(int*& q){
	            *q = 20; //修改指针指向的值
	            q = nullptr; //修改指针本身
	        }
	        int main(){
	            int x = 10;
	            int *p = &x; //p指向x
	            f(p); //此处是重头戏，q在此处变成了p的替身
	            cout << "x = " << x << endl;
	            cout << "p = " << p << endl;
	            return 0;
	        }
	    ```
- No arrays of references

