# 先来浅浅看个最简单的代码

```c
    #include<iostream>
    using namespace std;
    int main{
        cout << "Today I ma " << "19" << " years old " << "now" << endl;
        return 0;
    }
```

---

# cin 和 cout
## cin是输入，cout是输出：
```c
    #include<iostream>
    using namespace std;
    int main(){
        int number;
        cout << "Enter a decimal number : ";
        cin >> number;
        cout << "The number you entered is " << number << "." << endl;
        return 0;
    }
```

---

# endl

当你使用 `cout` 向控制台输出时，`endl` 的作用等同于你按下键盘上的回车键。它会把光标移动到下一行的开头，以便你接下来的输出内容会出现在新的一行。
但 `endl` 不仅仅是换行那么简单，它还包含了一个更重要的功能：**刷新缓冲区**。

## `endl` 的核心作用
1. **插入换行符**：这很好理解，就是让输出内容换到新的一行。
2. **刷新缓冲区**：这是 `endl` 和其他换行方式（比如 `\n`）最主要的区别。

**什么是缓冲区？** 为了提高效率，C++ 的 `cout` 不会每输出一个字符就立即把它打印到屏幕上。它会先把这些字符暂存在一个**缓冲区**（buffer）里，等缓冲区满了，或者遇到特定的指令时，再一口气全部打印出来。
`endl` 的第二个作用就是给出这个“特定指令”，告诉 `cout`：“别等了，赶紧把缓冲区里的东西都打印到屏幕上吧！”

---
# std

## `std`的含义
- 在C++中，`std::`是一个命名空间前缀，它表示我们正在使用 **标准库**中的东西。可以把它想象成一个大的工具箱，里面装着C++官方提供给你的各种工具、函数和类。

- 在C语言中，我们通常直接使用像`printf`、`scanf`这样的函数，因为它们是全局的。但在C++里，为了避免命名冲突（比如你自己定义了一个名叫`string`的变量，和标准库里的`string`类冲突了），C++把所有标准库的内容都放到了一个叫`std`的 **命名空间里。

## `std`命名空间的作用
- **组织代码，防止冲突**：就像你的电脑文件夹一样，把不同类型的文件放进不同的文件夹，这样就不会搞混。`std`就是C++标准库的“文件夹”。
    
- **明确来源**：当看到`std::string`时，你马上就知道这个`string`是来自C++标准库的，而不是你自己定义的。

## 常见的`std::`用法

你经常会在C++代码中看到以下这些：

- `std::cout`：用于向控制台输出内容。
- `std::cin`：用于从控制台获取输入。
- `std::endl`：用于换行并刷新缓冲区。
- `std::string`：用于处理字符串。
- `std::vector`：用于动态数组。
所以，`std::cout << "Hello, world!" << std::endl;` 这行代码的直译就是：“使用标准库里的`cout`，向它传入字符串`"Hello, world!"`，然后使用标准库里的`endl`来换行。”

## 懒人写法

如果觉得每次都写`std::`很麻烦，你可以在代码的开头加上 `using namespace std;`。
```c++
    #include <iostream>
    using namespace std; // 加上这行
    int main() {
        cout << "Hello, world!" << endl; // 就可以不用写std::了
        return 0;
    }
```
**但是！** 这种写法在**大型项目**和**头文件**中**不推荐**。因为这会把`std`命名空间里的所有东西都暴露出来，增加了命名冲突的风险。课堂中老师可能为了让我们养成好习惯，会展现完整的`std::`
简单来说，`std::`就是C++的标准操作，它能帮你把代码组织得更清晰、更安全。虽然刚开始看起来有点烦，但习惯之后就会觉得它很自然了。

---

# const

在C++中，`const`是一个关键字，它表示“**常量**”或“**不可变**”。简单来说，它告诉编译器，被`const`修饰的东西是不能被修改的。它跟reference一样定义的时候就得直接初始化。
这有什么用呢？它能让你在代码中明确地表达你的意图，让编译器来帮你检查错误，从而提高代码的健壮性和安全性。
`const` 可以用在许多地方：
## 1.修饰变量
当一个变量被 `const` 修饰后，它就成了一个常量，它的值在初始化后就不能再改变了。
```c++
    const int max_size = 100; // max_size现在是一个常量
    max_size = 200; // 错误！不能修改常量
```

## 2.修饰指针
这可能是最容易让人混淆的地方，因为 `const` 的位置不同，含义也不同：

- **常量指针（`const` 在 `*` 后面）**：指针本身可以改变，但它**指向的值**不能改变。
```c++
    int x = 5;
    const int* p = &x; // p指向的值是const的
    *p = 10;           // 错误！不能通过p修改x的值
    int y = 6;
    p = &y;            // 正确！p可以指向另一个变量
```

- **指针常量（`const` 在 `*` 前面）**：**指针本身**不能改变，但它指向的值可以改变。
```c++
    int x = 5;
    int* const p = &x; // p本身是const的
    *p = 10;           // 正确！可以通过p修改x的值
    int y = 6;
    p = &y;            // 错误！不能让p指向另一个变量
```

- **都修饰（两个 `const`）**：指针本身和它指向的值都不能改变。
```c++
    int x = 5;
    const int* const p = &x; // 指针p和它指向的值都不能变
    *p = 10;                 // 错误！
    int y = 6;
    p = &y;                  // 错误！
```

## 3.修饰函数

当我们在函数参数前加上 `const` 时，是在向调用者保证，这个函数**不会修改**传入的参数。这是一种很好的编程习惯，因为它让函数接口更清晰。
```c++
    void print_string(const std::string& str) {// 只能读取str，不能修改它
        std::cout << str << std::endl;
        str[0] = 'a'; // 错误！
    }
```