## 8.4.1. Noexcept异常说明
### 不抛出异常的方法：
- 如果确定某个函数能够正常运行，不会产生任何问题，可以用 noexcept 声明它不会产生异常，
形式如下：

```c++
    //不会抛出异常
    rtype f(……) noexcept {
     ……
     }
     
    //可能会抛出异常 
    rtype g(……){ 
    …… 
    }
```

- noexcept是C++11新标准提出的，，它与早期版本的 **`空throw`** 等价

```c++
    rtype f(...) throw(){
    ...
    }
```

### 拆解语法含义
- **`rtype`**: 函数的返回类型（比如 `int`, `void` 等）。
- **`f(...)`**: 函数名和它的参数列表。
- **`throw()`**: 这是核心部分。括号里 **什么都不写** ，意思就是：“这个函数 **不准抛出任何类型** 的异常”。


### 关于noexcept的两点补充

#### 1. 动态标签：`noexcept(e)`

`noexcept` 说明符实际上可以接受一个 bool 类型实参，形式是：`rtype f() noexcept(e)`

- **形式**：`rtype f() noexcept(e)`
- **逻辑**：
    - 如果 `e` 是 **`true`**：函数 `f` 保证不抛出异常（等同于直接写 `noexcept`）。
    - 如果 `e` 是 **`false`**：函数 `f` 可能会抛出异常。
- **为什么要这么麻烦？** 这通常用于**模板编程**。比如你写一个通用的“交换”函数，如果里面的数据类型支持不抛异常的交换，那这个函数就是 `noexcept(true)`；反之则是 `false`。
    
#### 2. 异常探测器：`noexcept` 运算符

Noexcept 同时也是一个可以用来判断函数是否会产生异常的运算符，形式为： `noexcept(e)`

当你把它当作运算符用在代码逻辑里时，它是在“询问”编译器： **“后面括号里这段代码，跑起来安全吗（会抛异常吗）？”**

- **形式**：`noexcept(e)`，这里的 `e` 是一个表达式。
- **结果**：它不会真的去运行 `e`，而是在编译阶段看 `e` 调用的函数是否有 `noexcept` 声明。
    - 如果有声明，结果就是 `true`。
    - 如果没有声明，结果就是 `false`。

**举个例子：** 假设你有两个函数 `f()` 和 `g()`，你想知道把它们加在一起运行是否安全： `noexcept(f(4) + g(6))`。

- 如果 `f` 和 `g` 都被打上了 `noexcept` 标签，这个探测器的结果就是 `true`。
- 只要其中有一个没打标签，结果就是 `false`。

---

## 8.4.2 捕获所有异常

在多数情况下， catch 都只用于捕获某种特定类型的异常，但 它也具有捕获全部异常的能力。其形式如下： 
```
    catch(…) {
     …… // 异常处理代码 
    }
```
### 核心语法：`catch(...)`

- **三个点 `...`**：它的意思是**“匹配任何类型”**。
- **功能**：无论 `try` 块里 `throw` 了什么，只要前面的 `catch` 都没有匹配上，这个 `catch(...)` 就一定会负责把异常接住。

![](附件/Pasted%20image%2020260107182600.png)

---

### 8.4.3 在异常处理块中再次抛出同一异常

![](附件/Pasted%20image%2020260107183510.png)![](附件/Pasted%20image%2020260107195045.png)

### Question：为什么第二行输出的是1而不是100
![](附件/Pasted%20image%2020260107200901.png)

---

## 8.4.4. 异常的嵌套调用
![](附件/Pasted%20image%2020260107201017.png)
![](附件/Pasted%20image%2020260107201040.png)
![](附件/Pasted%20image%2020260107204239.png)