# 五种内存模型

```c++
int i; //global vars

static int j; // static global vars
void f(){

    int k; //local vars
  
    static in l; //static local vars
  
    int *p = malloc(sizeof(int)); //allocated vars
}
```

## 这五种类型的存放地点

![](附件/Pasted%20image%2020250923000238.png)

---
!!! info "Global vars"
    ## Global vars
    - 定义在所有的函数之外
    - 可以被不同的cpp文件共享，需要用extern


!!! info "Extern"
    ## Extern
    - Extern is a declaration says there will be such a variable somewhere in the whole program（这个变量不是当前的文件定义的，我只是从整个程序中的某个地方把它引用过来而已）。
    - such a means the type and the name of the variable。
    - global variable is a definition, the place for that variable。
    
    下面是c++中运用extern的一个例子：
    
    ```c++
    #include<iostream>
    using namespace std;
    extern int global_var; //此处的global_var就是从别的.cpp文件中拉取过来的
    int main(){
        cout << "extern  global_var is: " << global_var << endl;
        return 0;
    }
    ```
    但是要成功运行的话必须在终端中将这两个.cpp文件同时编译
    并且在extern之后也一定要声明这个变量的类型，不能直接extern global_var

!!! info "Static"
    ## Static
    - static global variable inhibits access from outside the .cpp file(别的所有文件都访问不到，只有当前文件)。
    - so as the static function。
!!! info "Static local vars"
    ## Static local vars
    - static local variable value in between visits to the same function
    - is initialized at its first access

!!! tip "static local vars的作用"
    ## static local vars的作用：
    local vars是一个临时变量，当这段函数执行完之后就会消失，但是加上static时候它就不再是一个临时变量了，我们下次再执行到这个程序这个字段的时候，我们还可以读到上一次在这个位置写的或者修改的variable。它的作用就是把这个变量静态化，跟cpp文件绑在一块，这样就可以多次的访问多次的读。
    
    下面是我随便用c语言写的一个例子：
    
    ```c
    #include<stdio.h>
    int calculate(int x, int y);
    int main(){
        int i,j;
        j=1;
        for(i=0;i<5;i++){
        int sum = calculate(x, y);
        printf("%d\n",sum);
        }
        return 0;
    }
    int calculate(int x, int y){
        static int m=1;
        int n=1;
        n+=1;
        m+=1;
        return x+y+m+n;
    }
    ```
    像这段代码中，calculate函数中的m就是静态局部变量，n就是普通的局部变量，所以每次访问calculate函数的时候，n都会被重置为1，然后进行n++，但是m只会在第一次被定为1，之后再也不会被重置为1，而是随着这个函数被调用而一直+1，它的寿命已经超越calculate这个函数了。这也是为什么Static local vars也被放在了Global data中。

!!! info
    ## Dynamic memory allocation（动态内存分配）
    c++中的new和delete对应了c中的malloc和free。但是new和malloc还是有区别的，malloc是一个函数，需要给它一个指针还有length。但是new会自动分配合适的内存大小，比如new int就会分配int大小的内存。
    
    - new
        - new int；
        - new Stash;
        - new int [10];
    - delete
        - delete p;
        - delete[] p; //如果想要删数组的话必须加括号，不然只能删除一个数

!!! example
    ## 有关Dynamic arrays的例子
    int *psome = new int[10];
    
	- 因为new这个操作返回的是一个地址，我们需要用指针去接收这个地址，此处用了psome，也就是说psome指向了一段数组的起始位置。
	
    delete[] psome;
    - 因为我们之前定义的是数组，所以想要删干净的话必须在delete后面加一个[]，不然只能删一个元素。
    ![](附件/Pasted%20image%2020250923014651.png)

!!!tip
    ## Tips for new and delete
     - Don't use delete to free memory that new didn't allocate.
     - Don't use delete to free the same block of memory twice in succession.
     - Use delete[] if you used new[] to allocate an array.
     - Use delete（没有[]）if you used new to allocate a single entity.
     - It's safe to apply delete to the null pointer.（无事发生）
