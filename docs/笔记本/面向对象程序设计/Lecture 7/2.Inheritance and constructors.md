- Think of inherited traits as an embedded object（将继承的属性视为一个嵌入式对象）
    - 含义：当你创建一个`Manager`对象时，它在内存中就像一个大盒子，里面包含了一个完整的`Employee`小盒子
- 创建顺序：程序在创建`Manager`对象时，必须先创建并初始化内部的`Employee`小盒子，然后才能创建和初始化`Manager`自己特有的数据。

#### 代码示例
```c++
    Manager::Manager(const string& name, const string& ssn, const string& title = " ") : Employee(name, ssn), m_title(title){
    }
```

---

## More on constructors
1. Base class is always constructed first（基类总是先被构造）
    - 这与上面讲到的`Manager`继承`Employee`的例子直接相关。
    - 含义：当你创建一个子类对象（如`Manager`）时，程序会强制执行以下语句：
        1. 先调用父类(`Employee`)的构造函数，完成其内部通用属性（如`name`, `ssn`）的初始化。
        2. 再调用子类(`Manager`)的构造函数，完成其独有属性的初始化。
2. If no explicit arguments are passed to base class - Default constructor will be called.（如果没有显示参数传递给基类，则调用默认构造函数）
    - 含义：如果子类没有在初始化列表中显示指定参数来调用父类构造函数（如`:Employee(name, ssn)`）, 那么编译器就会尝试自动调用父类不带任何参数的默认构造函数
    - 后果：如果父类没有定义不带参数的默认构造函数，程序就会编译失败。
3. 析构函数按照构造函数的完全相反的额顺序调用
    - 这保证了子类在清理自身的时候，如果需要使用父类的任何功能或数据，这些资源仍然是完整的、没有被销毁的。

---

## Manager member functions
上一个笔记中已经定义了`Manager`这个类并且函数声明也已经完成，下面进行函数定义
```c++
    inline void Manager::print(std::ostream& out) const
    {
        Employee::print(out);
        out << m_title << endl;
    }
    inline const std::string& Manager::get_title() const
    {
        return m_title;
    }
    inline const std::string Manager::title_name() const
    {
        return string (m_title + ": "+ m_name);
    }
```

---

## Uses
```c++
    int main(){
        Employee bob("Bob Jone", "555-44-0000");
        Manager bill("Bill Smith", "666-55-1234", "ImportantPerson");
        
        string name = bill.get_name(); //OK, Manager inherits Employee
        string title = bob.get_title();//Error, bob is an employee
        
        cout << bill.title_name() << '\n' << endl;
        bob.print(cout);
        bob.print(cout, "Employee:");
        bill.print(cout);
        bill.print(cout, "Employee:");//Error -- hidden!
    }
```

---

## 下面将这节课写的代码编译一遍看看结果
```c++
    #include<iostream>
    using namespace::std;
    
    class Employee {
    public:
        Employee(const std::string& name, const std::string& ssn);
        const std::string& get_name() const;
        void print(std::ostream& out) const;
        void print(std::ostream& out, const std::string& msg) const;
        
    protected:
        std::string m_name;
        std::string m_ssn;
    };
    
    Employee::Employee(const string& name, const string& ssn):m_name(name), m_ssn(ssn){}
    
    inline const std::string& Employee::get_name() const{
        return m_name;
    }
        
    inline void Employee::print(std::ostream& out) const{
        out << m_name << endl;
        out << m_ssn << endl;
    }
    
    inline void Employee::print(std::ostream& out, const std::string& msg) const{
        out << msg << endl;
        print(out);
    }
    
    class Manager : public Employee{
    public:
        Manager(const std::string& name, const std::string& ssn, const std::string& title);
        const std::string title_name() const;
        const std::string& get_title() const;
        void print(std::ostream& out) const;
    private:
        std::string m_title;
    };
    
    Manager::Manager(const string& name, const string& ssn, const string& title = " ") : Employee(name, ssn), m_title(title){
    }
    
    inline void Manager::print(std::ostream& out) const
    {
        Employee::print(out);
        out << m_title << endl;
    }
    
    inline const std::string& Manager::get_title() const
    {
        return m_title;
    }
    
    inline const std::string Manager::title_name() const
    {
        return string (m_title + ": "+ m_name);
    }
    
    int main(){
        Employee bob("Bob Jone", "555-44-0000");
        Manager bill("Bill Smith", "666-55-1234", "ImportantPerson");
        
        string name = bill.get_name();
        string title = bob.get_title();//Error, bob is an employee
        
        cout << bill.title_name() << '\n' << endl;
        bob.print(cout);
        bob.print(cout, "Employee:");
        bill.print(cout);
        bill.print(cout, "Employee:");//Error -- hidden!
    }
    
```

### 最终的编译结果如下：
![](附件/Pasted%20image%2020251109175922.png)
### 下面给出两种正确的改法：
!!! answer "方法一"
    将`bill.print(cout, "Employee: ")`改成`bill.Employee::print(cout, "Employee: )"`
    
    这样便能够成功编译。
    
    但是将`bob.get_title();`改成`bob.Manager::get_title()`是没法成功编译的。
    
    #### 总结：子类成员能够访问到父类的`protected`以及`public`的成员，但是父类成员没法访问子类中特定的(父类中未定义，在子类中定义的)成员。哪怕是子类中新定义的`public`成员父类中也是访问不到的
    
    将`bob.get_title();`注释掉，并将`bill.print(cout, "Employee: ")`改成`bill.Employee::print(cout, "Employee: )"`之后，得出的结果如下：
    ![](附件/Pasted%20image%2020251109182816.png)

!!! answer "方法二"
    将`bill.print(cout, "Employee: "`注释掉，改成以下代码：
    ```c++
        Employee *ep = &bill;
        ep -> print(cout);
        ep -> print(cout, "Employee: "); 
    ```
    ![](附件/Pasted%20image%2020251109183544.png)

---

## Name hidding

- If you redefine a member function in the derived class, all other overloaded functions in the base class are inaccessible.（如果你再子类中重新定义了跟父类中同名的成员函数，那么父类中所有其它重载版本的这个同名的函数（哪怕参数类型或者个数不一样）都会被隐藏，变得不可访问。）
    - 上面的例子中，`bill.print(cout, "Employee: ");`出错的原因就是`Manager`这个子类中也定义了`print`函数，这个`print`函数把父类中的所有`print`函数都覆盖掉了，因此bill无法访问父类中的`print(std::ostream& out, std::string& msg)`函数，而它自身也没定义这个函数，故报错。

---
## 穿插一个小例子
```c++
    #include<iostream>
    using namespace::std;
    class A{
    public:
        A(){
            i=10;
            cout << "A()" << i << endl;
        }
        ~A(){
            cout << "~A()" << endl;
        }
    private:
        int i;
    };
    
    class B : public A{
    public:
        B(){
            j=20;
            i=5;
            cout << "B()" << i << " " << j << endl;
        }
        ~B(){
            cout << "~B()" << endl;
        }
    private:
        int i;
        int j;
    };
    
    int main(){
        cout << sizeof(A) << " " << sizeof(B) << endl;
        
        B b;
        cout << b.B::i << endl;
        cout << b.A::i << endl;
        return 0;
    }
```
### 编译结果如下：
![](附件/Pasted%20image%2020251109192034.png)
问题出在了`main`函数中访问不到`A`与`B`类中的`private`变量，因此需要把`private`改成`public`
### 改正后的输出结果如下
![](附件/Pasted%20image%2020251109192337.png)
这个输出结果说明了，即使在B类中重新定义了i，A类中存在的仍然存在于B中，这也是B的size是12而不是4的原因。

---

## Access protection
1. `Public`: visible to all clients
2. `Private`: visible only to self and to friends（只对自身以及友元可见）
    - 只有定义这个成员的类内部的方法才能访问它。
        在我们之前的例子中，`Employee`的属性`m_name`, `m_ssn`被标记为`protect`，但如果它们被标记为`private`，那么：
            1. 连子类（`Manager`这些）都不能直接访问到
            2. 外部代码必须通过`public`方法（如`get_name()`）来间接访问这些数据。
3. `Protected`: visible to classes derived from self and to friends
    - 外部客户端代码无法访问。
    - 所有直接或间接的子类都可以像访问自己的成员一样访问它。

### Friends
我们知道`private`和`protected`成员是隐蔽的，外部代码不能直接访问。但在某些情况下，程序员有意识地希望某个外部函数或另一个类能够访问自己私有的或受保护的数据，同时又不想将这些数据改为`public`，那么`friend`就派上用场了。

1. To explicitly grant access to a function that isn't a member of the structure.（明确授予对非结构体成员的函数的访问权限）
    - 将一个函数声明为友元，该函数就获得了与该类的成员函数相同的权限，可以直接访问该类的所有`private`和`protected`成员。
2. The class itself controls which code has access to its members.
    - 友元权限是单向的，只有类才能决定谁是它的友元
3. Can declare a global function as a friend, as well as a member function of another class, or even entire class, as a friend.
    - 可以将一个全局函数声明为友元。
        - 一个全局函数是不属于任何类，独立于所有类定义存在的函数。
    - 可以将另一个类的成员函数声明为友元。
        - 如果只有另一个类A的某一个特定方法需要访问我的私有数据，我可以只将这个方法声明为友元，而不是将整个类都声明为友元。
    - 可以将整个类声明为友元。
        - 如果一个类需要全面的对另一个类的私有数据进行操作，可以将其中一个类的所有函数成员都声明为另一个类的友元。

---

## How inheritance affects access
假设B是从A中衍生出来的。
![](附件/Pasted%20image%2020251109024830.png)

---

## Scopes and access in c++
![](附件/Pasted%20image%2020251109192701.png)
这张图将类成员的访问权限分为三个主要实体来描述： **客户端代码 (Client Class)** 、 **基类 (Base Class)** 和 **派生类 (Derived Class)** 。

### 1. 基类 (Base Class) 的成员
基类中声明了三种类型的成员：

- `Public (int pub;)`
- `Protected (int prot;)`
- `Private (int priv;)`

### 2. 客户端代码（外部代码）的视角
客户端代码 (Client Class) 指的是任何创建该类对象并在其外部使用这些对象的代码（例如 main() 函数中的代码）

- 访问基类 (Base Class)：
    - 客户端只能看到（访问）基类的 Public 成员 (pub)。
    - Protected 和 Private 成员对客户端是隐藏的，无法直接访问。
- 访问派生类 (Derived Class)：
    - 客户端能看到（访问）派生类中最终是 Public 的成员，这包括：
        - 从基类继承下来且在派生类中保持 Public 的成员 (pub)。
        - 派生类自己定义的 Public 成员 (pub2)。

### 3. 派生类 (Derived Class) 的视角
派生类 (Derived Class) 是继承自基类的子类。

- 访问基类成员：
    - 派生类可以访问基类的 Public 成员 (pub)。
    - 派生类可以访问基类的 Protected 成员 (prot)。
    - 派生类不能直接访问基类的 Private 成员 (priv)。



---
## Conversions
- Public Inheritance should imply substitution
- If B is-a A, you can use a B anywhere an A can be used（如果B是A，那么可以在任何可以使用A的地方使用B）
    - 这正是我们之前讨论`Manager`继承`Employee`的意义。因为`Manager`是一个`Employee`，所以你可以在需要`Employee`对象的函数中传入一个`Manager`对象

### D is derived from B

| **转换对象**                | **转换方向** | **含义**                                                                                                                                             |
| ----------------------- | -------- | -------------------------------------------------------------------------------------------------------------------------------------------------- |
| **`D` $\implies$ `B`**  | 对象到对象    | **从派生类对象到基类对象的转换**。例如，将一个 `Manager` 对象赋值给一个 `Employee` 对象。**注意**：这通常会导致数据截断 (slicing)，即 `Manager` 独有的数据（如 `title`）会丢失。                             |
| **`D*`$\implies$`B*`**  | 指针到指针    | **从派生类指针到基类指针的转换**。例如，你可以将一个 `Manager*` 赋值给一个 `Employee*`。这是**多态**的基础，允许基类指针指向派生类对象。                                                               |
| **`D&`$\implies$ `B&`** | 引用到引用    | **从派生类引用到基类引用的转换**。例如，可以将一个 `Manager&` 传递给需要 `Employee&` 的函数参数。这也是 **多态** 的基础，它允许我们使用一个通用的接口 (`Employee&`) 来操作不同类型的对象 (`Manager` 或 `Employee` 本身)。 |

---

## class vs. struct

 - class defaults to private
 - struct defaults to public