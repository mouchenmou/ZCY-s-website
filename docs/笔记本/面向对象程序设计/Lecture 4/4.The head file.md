1. **If a function is declared in a header file, you _must_ include the header file everywhere the function is used and where the function is defined.**
    
    - **函数的使用（Used）：** 任何调用该函数的 `.cpp` 文件都需要包含头文件。这是因为编译器在看到函数调用时，需要头文件中提供的 **函数声明/原型**（即函数的签名）来检查调用的正确性，并知道如何生成一个待链接的调用指令。
        
    - **函数的定义（Defined）：** 即使在定义函数体的 `.cpp` 文件中，通常也应该包含对应的头文件。这样做有两个主要目的：
        
        - **一致性检查：** 确保 `.cpp` 文件中定义的函数体签名与头文件中的声明完全一致。如果签名不匹配，编译器会立即报错。
            
        - **内联函数：** 如果函数是 `inline` 的，它的定义需要在每个使用它的地方都可见，所以必须放在头文件中。
            
2. **If a class is declared in a header file, you _must_ include the header file everywhere the class is used and where class member functions are defined.**
    
    - **类的使用（Used）：** 任何创建该类的对象、使用该类的成员变量、或者使用该类作为函数参数或返回值的 `.cpp` 文件，都需要包含头文件。因为编译器需要知道该类的完整结构（包括所有成员变量和方法的声明）来确定对象的大小和访问权限。
        
    - **成员函数的定义（Defined）：** 在包含该类成员函数具体实现的 `.cpp` 文件中，必须包含头文件。这与第一点中函数定义时包含头文件的原因相同：
        
        - 确保函数实现与类声明中的原型一致。
            
        - 告知编译器这些函数体属于头文件中声明的特定类。

!!! summary
    ## Summary：
    核心思想是，头文件是 C++ 中实现 “声明”与“定义”分离 的关键。头文件提供了任何代码实体（如函数、变量、类）的接口信息（即如何使用它们），因此任何想要使用或实现这些实体的文件，都必须包含相应的头文件。这是 C++ 编译模型能够正常工作的基本要求。
    
    首先在.h中声明，其次在.cpp中定义，编译过后就会变成既有声明又有定义的模块，如下图所示：
    ![](附件/Pasted%20image%2020251016212721.png)
    如果其它的模块也要用到这个功能的时候，那这个模块的.cpp文件也需要包含要引用的功能的头文件(比如说line.cpp需要用到point这个功能，那么line.cpp就需要执行include"point.h")，如下图所示：
    ![](附件/Pasted%20image%2020251016212146.png)

---
## Tips for  header
1. One class declaration per header file (每个头文件只包含一个类的声明)

    - 目的： 这是为了提高代码的模块化和可维护性。当用户需要使用某个类时，他们只需要包含对应的头文件。如果一个头文件里有多个不相关的类，会增加代码耦合度，且在只需要其中一个类时也必须处理所有类的声明。

2. Same name with .cpp file (与 .cpp 文件使用相同的名称)

    - 目的： 这是 C++ 的标准命名约定。如果有一个类叫做 MyClass，通常它的声明放在 MyClass.h 或 MyClass.hpp 中，而它的实现放在 MyClass.cpp 中。

    - 好处： 这样可以清晰地建立头文件（接口）和源文件（实现）之间的对应关系，方便开发者查找和管理文件。

3. The contents of a header file is surrounded with `#ifndef` `#define ...` `#endif` (头文件的内容被 `#ifndef` `#define ... ``#endif` 包围)

    - 目的： 这就是前面提到过的包含卫士（Include Guards）。

    - 作用： 确保在单个编译单元中，即使这个头文件被多次 `#include`，其内容也只会被预处理器处理一次，从而防止多重定义错误（Redefinition Errors）。

4. Start a header file with `#pragma once` (用 #`pragma once` 开始一个头文件)

    - 目的： 这是另一种防止头文件重复包含的现代方法。

    - 作用： 它告诉编译器在同一编译单元中只包含该文件一次。

    - 实践： 在现代 C++ 开发中，`#pragma once` 和包含卫士（第 3 点）是并存的。许多开发者倾向于只使用更简洁的 `#pragma once`，但如果追求最高的兼容性（可移植性），则会使用包含卫士，或者为了安全起见，两者都使用。