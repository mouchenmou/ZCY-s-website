## What is STL ?
![](附件/Pasted%20image%2020251130212631.png)

---
## Why should I use STL ?
![](附件/Pasted%20image%2020251130212727.png)

---
## C++ Standard Library
#### 1. `pair` 类
- **A pair class (pairs of anything, int/int, int/char, etc)**
    - `std::pair` 是一个简单而强大的模板类，用于将两个不同或相同类型的值组合成一个单一的对象。
    - **用途：** 经常用于从函数返回两个值，或作为 `std::map` 中键值对的基本结构。
    - ![](附件/Pasted%20image%2020251130213843.png)
    - ![](附件/Pasted%20image%2020251130213910.png)

#### 2. Containers (容器)
容器是 STL 的核心，用于高效地存储和管理数据。

- **`vector` (expandable array)**
    -  动态数组。它允许在末尾快速插入和访问元素，并且可以自动增长大小。
- **`deque` (expandable array, expands at both ends)**
    - 双端队列。类似于 `vector`，但它支持在两端（前端和后端）快速插入和删除元素。
- **`list` (double-linked)**
    -  双向链表。它允许在列表的任何位置以常数时间 $O(1)$ 复杂度快速插入和删除元素，但随机访问（按索引访问）较慢。
- **`set` and `map`**
    - `set`：存储唯一的有序元素，用于快速查找。  
    - `map`：存储**键值对**（Key-Value pairs），键是唯一的，用于通过键快速查找对应的值。
            
#### 3. Basic Algorithms
- **Basic Algorithms (sort, search, etc)**
    - 标准库中的 `<algorithm>` 头文件提供了大量泛型算法，可以作用于不同的容器。
    - **用途：** 比如 `std::sort` (排序)、`std::find` (查找) 等，这些算法经过高度优化，且可以与所有 STL 容器配合使用。

#### 4. 命名空间约定
- **All identifiers in library are in `std` namespace**
    
    - * C++ 标准委员会将标准库中所有名称（如 `vector`, `sort`, `pair` 等）都放在了 `std` (standard 的缩写) 命名空间内，以防止与用户自定义的名称发生冲突。
    - **使用方式：**
        - 必须使用 `std::` 前缀来访问它们，例如 `std::vector`。
        - 或者使用 `using namespace std;` 语句来引入整个命名空间（尽管在大项目中通常不推荐这样做，因为它可能带来新的命名冲突）。

---

## 最常用的三种数据结构

#### 1. `map`（映射）

- **Any key type, any value type.** (任何键类型，任何值类型。)
    - `map` 存储键值对（Key-Value pairs）。键（Key）用于查找，值（Value）是存储的数据。它们可以是任何 C++ 类型。        
- **Sorted.** (有序的。)
    - `std::map` 内部通常由 **平衡二叉搜索树** （红黑树）实现，它根据键的顺序自动排序元素。这使得它支持高效的查找、插入和删除操作，时间复杂度通常为 $O(\log n)$。
            
- **用途：** 适用于需要根据唯一键快速查找对应值的情况，例如电话簿、字典、配置表等。
    

#### 2. `vector`（动态数组）
    
- **Like c array, but auto-extending.** (类似于 C 数组，但自动扩展。)
    - `vector` 是 C++ 中最常用的容器。它在内存中是**连续存储**的，像普通数组一样。   
    - 与 C 数组不同，当元素数量超过当前容量时，`vector` 会 **自动分配更大的内存** ，并将现有元素复制过去，实现“自动扩展”。
            
- **用途：** 适用于大多数需要高效**随机访问**（通过索引 $O(1)$ 访问）和在 **末尾快速添加** 元素的情况。
    

#### 3. `list`（链表）
    
- **doubly-linked list** (双向链表)
    - `std::list` 内部的每个元素都存储了指向**前一个**元素和**后一个**元素的指针。
    - 由于元素在内存中**不一定是连续的**，它不支持快速随机访问（通过索引访问速度慢）。
            
- **用途：** 适用于需要频繁在 **列表中间** 进行 **插入** 和 **删除** 操作的情况（这些操作的复杂度为 $O(1)$，非常快）。

---
## All Sequential Containers

#### 1. `vector` (动态数组)
- **特点：** 可变大小的数组 (`variable array`)。
- **内存：** 内存是连续存储的。
- **访问：** 支持快速的**随机访问**（通过索引 $O(1)$）。
- **增删：** 支持在**末尾**快速添加和删除元素。在中间插入或删除元素较慢（$O(n)$）。
    

#### 2. `deque` (双端队列)
- **特点：** 双端队列 (`dual-end queue`)。
- **内存：** 内存由多块连续存储区组成。
- **增删：** 支持在 **头部** 和 **尾部** 都进行快速的插入和删除操作。
- **访问：** 也支持随机访问，但通常比 `vector` 稍慢。
    

#### 3. `list` (双向链表)
- **特点：** 双向链表 (`double-linked-list`)。
- **内存：** 元素通过指针连接，在内存中不连续。
- **增删：** 支持在**任何位置**进行常数时间 $O(1)$ 的 **快速插入和删除** 操作。
- **访问：** 不支持快速随机访问（通过索引访问速度很慢）。
    

#### 4. `forward_list` (单向链表)
- **特点：** 单向链表 (`as it`)。
- **内存：** 比 `list` 更节省内存，因为它只存储指向下一个元素的指针。
- **增删：** 只支持从 **头部** 进行快速插入和删除。
- **用途：** 适用于只需要从头到尾顺序遍历的场景。
    

#### 5. `array` (静态数组)

- **特点：** 固定大小的数组 (`as "array"`)。
- **内存：** 内存是连续存储的。
- **大小：** 长度在 **编译时固定** ，不能动态改变。
- **用途：** 提供了 C 风格数组的效率，但具有标准库容器的安全性和功能（如支持迭代器）。
    

#### 6. `string` (字符串容器)
- **特点：** 字符数组 (`char array`)。
- **本质：** 专门用于存储字符序列的容器。
- **特性：** 行为上类似于 `vector<char>`，但提供了大量针对字符串操作的专用成员函数。

---

## Exampl using the vector class
![](附件/Pasted%20image%2020251130221722.png)

---

```c++
    #include<iostream>
    #include<vector>
    using namespace std;
    
    void print_size(vector<int> &v){
        cout << "size: " << v.size() << " " << "capacity: " << v.capacity() << endl;
    }
    
    int main(){
        vector<int> v(151);
        v[10] = 10;
        print_size(v);
        
        v.push_back(10);
        print_size(v);
        
        v.resize(1000);
        print_size(v);
        
        v.reserve(2000);
        print_size(v);
        
        v.clear();
        print_size(v);
        
        v.shrink_to_fit();
        print_size(v);
        
        vector<int> v2(5);
        v2.swap(v);
        print_size(v);
        
        return 0;
    }
```

![](附件/Pasted%20image%2020251130222912.png)

---
## Two ways to use Vector

#### 1. Preallocate
```c++
    vector <int> v(100);
    v[80] = 1; //OK
    v[200] = 1; //Bad    
```

#### 2. Grow tail
```c++
    vector<int> v2;
    int i;
    while (cin << i)
        v.push_back(i);
```
方法二避免了溢出风险