
## Constructions vs. assignment（构造与赋值的区别）

- **Every object is constructed once"** (每个对象只被构造一次)
    - 对象在创建时会调用它的构造函数（包括默认构造函数、带参数的构造函数或拷贝构造函数）。这是对象生命周期的起点，负责初始化对象的状态和资源。
- **"Every object should be destroyed once"** (每个对象只应该被销毁一次)
    - 对象在生命周期结束时会调用它的析构函数。析构函数负责释放对象占用的资源（例如使用 `new` 分配的内存）。
        - **"Forget to invoke delete"** (忘记调用 `delete`)：会导致内存泄漏。
        - **"Invoke delete more than once"** (调用 `delete` 多次)：通常发生在浅拷贝或管理同一块内存的多个指针上，会导致未定义行为或程序崩溃。
- **"Once an object is constructed, it can be the target of many assignment operations"** (一旦对象被构造，它可以成为多次赋值操作的目标)
    - **区别：** 构造函数是在对象初始化时被调用。而赋值运算符（`=`）是在对象已经存在的情况下，用另一个对象的状态来覆盖它的状态。
    - **重要性：** 正因为赋值操作可能发生多次，所以自定义的赋值运算符 (例如为了处理深拷贝) 必须特别小心。在执行赋值前，它通常需要：
        1. 释放目标对象（左侧对象）当前持有的旧资源。
        2. 从源对象（右侧对象）那里复制新资源。
        3. 避免自我赋值（`a = a;`）带来的释放错误。
            

---
## Copy ctor guidelines

#### 1. 默认情况下的省略
- **“In most cases, you don't have to write.”** (在大多数情况下，你不需要编写。)
    - 如果你的类成员都是标准库类型（如 `std::string`, `std::vector`）或基本数据类型（如 `int`, `double`），那么编译器生成的默认拷贝构造函数就足够了。因为这些标准库类型内部已经实现了正确的深拷贝语义。
        
#### 2. 需要自定义的情况
- **“Be explicit when necessary, e.g., managing raw pointers.”** (在必要时要明确编写，例如，管理原始指针时。)
    - **“create your own copy ctor”** (创建你自己的拷贝构造函数)
    - **解释：** 当你的类成员包含原始指针并管理着动态分配的资源，你必须手动编写深拷贝构造函数来防止浅拷贝和资源共享问题。
        

#### 3. 禁止拷贝的情况

- **“If you don't need one declare a private copy ctor (no need to define the body).”** (如果你不需要它，就声明一个私有的拷贝构造函数。)**
    - **解释：** 有些类设计上就不允许被复制（例如，代表唯一资源的类，如文件句柄或互斥锁）。
    - **如何禁止：** 将拷贝构造函数声明为 `private`。由于该函数是私有的，任何外部代码试图调用它进行复制时，编译器都会报错。
    - **“prevents creation of a default copy constructor”** (阻止默认拷贝构造函数的创建)
        - 实际上，声明任何自定义的拷贝构造函数（即使是私有的）都会阻止编译器自动生成默认版本。
    - **“generates a compiler error for copy”** (为拷贝操作生成一个编译器错误)
        - 如果外部代码试图复制一个对象，就会因为权限不足（`private`）而导致编译错误，从而有效地**禁止了拷贝**。
    - “use 'Person(const Person &rhs) = delete;'”
        - C++11 引入了 `= delete` 语法，可以直接在函数声明后加上它，明确告知编译器：**禁止生成和使用这个函数**。

---

## Uses of static in c++
### 1. 静态自由函数 (Static Free Functions)

- **位置：** 在任何类和函数之外，在 `.cpp` 文件中定义。
    
- **效果：** **内部链接**
    
- **解释：** 它将函数的可见范围限制在定义它的当前 `.cpp` 文件内部。其他文件无法调用或访问这个函数。
    
- **用途：** 隐藏那些只为当前文件内部代码服务的工具函数，防止函数名污染全局命名空间。
    
- **比喻：** 社区内部的私人工具。只有这个社区（`.cpp` 文件）的人知道并能使用这个工具。
    

### 2. 静态全局变量 (Static Global Variables)

- **位置：** 在任何类和函数之外，在 `.cpp` 文件中定义。
    
- **效果：** **内部链接 (Internal Linkage)**
    
- **解释：** 它将变量的可见范围限制在定义它的当前 `.cpp` 文件内部。即使其他文件有一个同名的全局变量，它们也是完全独立、互不干扰的。
    
- **用途：** 存储只在特定文件内部使用的全局配置或状态数据，避免全局命名冲突。
    
- **比喻：** 社区专属的公告牌。只有这个社区的人能看到并修改这个公告牌上的信息。
    

### 3. 静态局部变量 (Static Local Variables)

- **位置：** 在函数体内部定义。
    
- **效果：** **持久存储 (Persistent Storage)**
    
- **解释：** 它的生命周期被延长到 **整个程序运行期间** 。它只在函数第一次被调用时初始化一次。函数执行完毕后，它的值会保留下来，下次调用函数时，它会使用上次保留的值。
    
- **用途：** 让函数拥有“记忆”，用于跟踪函数被调用的次数、作为局部缓存等。
    
- **比喻：** **函数的“笔记本”。** 函数每次执行都会查看这个笔记本，并在上面记录新的状态。这个笔记本随函数而生，程序结束才销毁。
    

### 4. 静态成员变量 (Static Member Variables)

- **位置：** 在类定义内部声明，在类定义外部初始化。
    
- **效果：** **被所有实例共享 (Shared by all instances)**
    
- **解释：** 这个变量不属于任何一个特定的对象，而是属于**整个类**。所有由该类创建的对象都共享这一个变量的唯一副本。任何一个对象修改了它，其他对象都会看到改变。
    
- **用途：** 统计当前已创建的该类对象的总数、存储所有对象共享的常量或配置。
    
- **比喻：** **班级的共同财产（班费）。** 所有学生（对象）共享一个班费账户，任何人动用都会影响总余额。
    

### 5. 静态成员函数 (Static Member Function)

- **位置：** 在类定义内部声明。
    
- **效果：** **独立于对象，只能访问静态成员变量**
    
- **解释：** 这个函数不依赖于任何特定的对象实例。您可以通过类名直接调用它，不需要先创建一个对象。因为没有对象实例，它不能访问类的非静态（普通）成员变量。它主要用于操作静态成员变量。
    
- **用途：** 提供类级别的工具函数，例如用于获取静态成员变量的值（比如获取总对象数）。
    
- **比喻：** **班级的联络员。** 你可以直接通过班级（类名）联系他，他只负责处理和汇报共同财产（静态成员变量）的信息。


