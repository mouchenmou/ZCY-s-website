## 7.4.1 模板参数类型推导
- 模板参数常用值类型、左值引用、右值引用等
![](附件/Pasted%20image%2020260103201923.png)
### 1. 传值模板参数

值类型模板参数形式如下：

```c++
    template<typename param>
    r_type fun(param p, ...)
    {...}
```

- 这里的 `r_type` 代表该函数有一个返回类型
- 调用fun()时，编译器根据传递给p的实参类型推导出模板参数param的实际类型，并以此实例化生成模板函数。
- 编译器在推导模板参数param类型的过程中，会除去所有加在实参上的类型限定符（包括`const`、`&`和`&&`）以体现函数的值形参语义。因为这样才能够保证模板函数值形参可复制的语义（函数调用时将实参的值复制到值形参变量中）。

![](附件/Pasted%20image%2020260103183744.png)

### 2. 左值引用模板参数
模板参数的形式如下：

```c++
    template<typename param>
    r_type fun(param &p, ...){...}
```

- 当类型参数Parameter为可变引用（左值引用）时，可以向它传递能够推断出地址的实参，如果是const类型的实参，将保留它的const限定。
- 但是，不能够接受字面常量和临时变量，这是因为引用参数时可以修改实参值的，但将常量和临时变量传给引用参数，就与该语义相违背了。
- 修改例7.6，将f()的类型参数改为引用参数。
- **当类型参数为左值引用时，无论实参是左值还 是右值，推断出的模板参数都是左值。 **
- **当类型参数是右值引用时，只有当实参也是右值时，推断出的模板参数才是右值引用。**

![](附件/Pasted%20image%2020260103185131.png)

![](附件/Pasted%20image%2020260103184724.png)

### 3. 右值引用模板参数
![](附件/Pasted%20image%2020260103185355.png)
![](附件/Pasted%20image%2020260103202348.png)
![](附件/Pasted%20image%2020260103202503.png)

---

## 7.4.2 内联与常量函数模板
函数模板和类模板都可以定义为inline和constexpr函数。方法是将inline和constexpr放在函数参数列表之后，函数返回类型之前。

如果一个函数被声明为 constexpr，就意味着这个函数具备在编译阶段就计算出结果的能力，而不是等到程序运行的时候才去计算。

- ```c++
    template <class T>
    inline T min(T a, T b){
        return a<b? a:b;
    }
  ```
- ```c++
    template <class T>
    constexpr T min(T a, T b){
        return a<b? a:b;
    }
  ```
- 下面模板声明则是错误的，inline关键字的位置不对
```c++
    inline template <class T>
    T min(T a, T b){
        return a<b? a:b;
    }
```

---

## 7.4.3 默认模板实参
- 模板参数可以指定默认值（包括模板函数和类模板）
- 遵守与函数默认同样的规则：一旦为某个模板参数指定了默认值，则它右边的模板参数都应该有默认值。

### 设计比较两个不同类型数字大小的函数模板compare，第二个模板参数的类型默认为double。当第一个参数大于第二个参数时返回1，小于第二个参数时返回1，相等返回0。
![](附件/Pasted%20image%2020260103204453.png)
![](附件/Pasted%20image%2020260103205026.png)
![](附件/Pasted%20image%2020260103205049.png)

---

## 7.4.4 仿函数应用
- 简单来说，仿函数本质上是一个对象，但它的行为表现得像一个函数。在 C++ 中，它是通过在类（class 或 struct）中重载“括号运算符” operator() 来实现的
- 外观： 调用时看起来像函数，例如 obj(arg1, arg2);。
- 本质： 实际上是调用了该对象所属类的 operator() 成员函数。
![](附件/Pasted%20image%2020260103213043.png)

1. 仿函数基本概念：仿函数又叫函数对象，可以像调用函数一样使用对象。实际是类的函数调用运算符函数operator()的重载函数。
2. 仿函数的定义形式：

```c++
    class A{
        A operator()(参数表){...} 
    }
```

举例：
```c++
    class MyFunctor {
    public:
        // 重载括号运算符
        void operator()(int x) { 
            cout << x << endl; 
        }
    };
```
3. 与普通函数的区别：仿函数可以灵活应用于自身或其它函数。例如：
```c++
    A obj;
    obj(...);
```

### 设计一个通用求和、积的函数模板accumulate()，调用模板类Add和Mul的仿函数计算数据期间的和或积。

![](附件/Pasted%20image%2020260103212915.png)

### 举个生活化一点的例子：
```c++
    #include <iostream>
    using namespace std;

    // 1. 定义一个类
    class TaxCalculator {
    public:
        float taxRate; // 记事本：记录税率

        // 构造函数：初始化时确定税率
        TaxCalculator(float rate) : taxRate(rate) {}

        // 2. 关键：重载括号运算符，让对象能像函数一样被调用
        float operator()(float salary) {
            return salary * taxRate;
        }
    };

    int main() {
        // 3. 创建一个仿函数对象（设置税率为 0.1）
        TaxCalculator payTax(0.1);

        // 4. 像调用函数一样使用这个“对象”
        float result = payTax(10000); // 看起来像函数调用，其实是对象在干活
        cout << "应缴税款: " << result << endl;

        return 0;
    }
```

---

## 7.4.5 成员模板
![](附件/Pasted%20image%2020260103220750.png)
1. 成员模板的概念
    - 通常我们定义类时，成员函数的参数类型是固定的。但有时我们希望某个成员函数能处理多种不同类型的数据，这时就可以将其定义为模板。
    - 适用范围： 普通类（Ordinary Class）和类模板（Class Template）都可以拥有成员模板。
    - 本质： 它是一个隶属于类的“模板函数”。
2. 使用规则
    - 图片列出了三个关键点，这在编程实践中非常重要：
    - 定义方式： 它的语法和普通的“函数模板”完全一样，使用 `template <typename T>` 关键字。
    - 访问权限： 它是类的“亲儿子”。虽然它是模板，但它依然遵循类的封装性。它可以自由访问类的 private、protected 成员，并受访问限定符的约束。
    - 不能是虚函数（Virtual Function）： 这是 C++ 的一个硬性规定。 成员模板不能声明为 virtual。
        - 原因： 虚函数表（vtable）的大小在类编译时就需要确定，而模板只有在调用时才实例化。如果允许模板虚函数，编译器将无法预知会有多少个实例，从而无法构建虚函数表。

### OutArray是一个数组输出的代理类，为它设计一个成员模板，用于输出指定大小的不同类型数组值。

```c++
    #include<iostream>
    using namespace std;
    class OutArray{
    public:
        OutArray(ostream& o = cout):os(o){}
        template<typename T>void operator()(T*a; int n){
            for(int i = 0; i<n; i++)
                os<< a[i] << "\t";
            os << endl;
        }
    private:
        ostream & os;
    }
```
![](附件/Pasted%20image%2020260103221921.png)

---
## 7.4.6 可变参数函数模板

1. 关于可变参数函数模板
    - 参数类型和个数都不确定的函数模板，即可变参数模板
    - 此模板为功能需求明确，但数据类型和参数个数不确定的程序设计提供了更大的灵活性。
2. 可变参数函数模板的定义方法
```c++
    template<typename T1, typename...T2>
    r_type f(T1 p, T2..., arg)
    {
    
    }
```

- 其中，T2就是可变模板参数，称为参数包，可以是零个或多个类型不同的模板参数。

### 设计max函数模板，能够从任意多个数字中计算最大值。

```c++
    #include<iostream>
    using namespace std;
    
    //基础模板，处理最后一个参数，递归终止
    template <typename T>
    mymax(T t){
        return t;
    }
    
    //边长模板，处理二个以上的参数
    template <typename T1, typename... T2>
    double mymax(T1 p, T2... arg) {
        double ret = mymax(arg...); 
        return (p > ret) ? p : ret;
    }
    
    int main(){
    cout << mymax(1, 12, 3, 4, 20) << "\t"; //输出：20
    cout << mymax('5', 32, '2',23.0) << "\t"; //输出：53 (‘5’的ASCII)
    cout << mymax('a', 'z', 2) << "\t"; //输出：122 （‘z’的ASCII）
    cout << mymax(2, 3.2) << endl; //输出：3.2
    return 0;
```

3. 可变参数函数模板的执行过程
    (1)包扩展：可变参数函数通常都是递归调用的，函数执行时先处理包中的第一个实参，完成后再调用包中的剩余实参调用函数，称为包扩展。
![](附件/Pasted%20image%2020260104000923.png)
![](附件/Pasted%20image%2020260104001016.png)
(2)包扩展结束

- 为了终止递归，通常会为可变参数模板定义一个非可变参数的普通函数。

---

## 7.4.7 元编程的基本概念
![](附件/Pasted%20image%2020260104001715.png)
![](附件/Pasted%20image%2020260104001731.png)

---

## 7.4.8 模板重载、特化、非模板函数及调用次序

### 1. 模板重载

- 模板可以被另一个模板或普通函数重载
- 同函数重载的规则相同，要求重载的同名函数模板必须具有不同的形参表

### 设计从两个数中找出最大值的函数模板，并重载该函数模板，实现从任意三个数中找出最大值的函数模板。

```c++
    #include<iostream>
    #include<string>
    using namespace std;
    template <typename T>
    inline T const& max(T const& a, T const& b){
        return a < b ? b : a;
    }
    
    template inline T const& max(T const& a, T const& b, T const& c){
        return max(max(a, b), c);
    } 
    
    int main(){ 
        int a = 5, b = 12;
        string s1 = "aString1", s2 = "aZtring2";
        const char* c1 = "hellow template override!";
        const char* c2 = "hellow C++ 11!";
        const char* c3 = "hellow everyone!";
        cout << max(7, 42,32) << endl; //L1 输出42
        cout << max(a, b) << endl; //L2 输出12
        cout << max(s1, s2) << endl; //L3 输出aZtring 
        cout << max(c1, c2,c3) << endl; //L4 
        cout << max(c1, c3) << endl; //L5 
    }
```
L4 、 L5 的错误原因是重载的 max函数模板不能从 char * 类型的字符串中找出正确的最大值。解决方法是特化模板或定义正确的变通函数。

### 2.模板特化
![](附件/Pasted%20image%2020260104002906.png)
![](附件/Pasted%20image%2020260104002957.png)
![](附件/Pasted%20image%2020260104003058.png)

### 3.为模板补充普通函数
![](附件/Pasted%20image%2020260104003210.png)
```c++
    #include<iostream>
    #include<string>
    using namespace std;
    template <typename T>
    inline T const& max(T const& a, T const& b){
        cout<<“3:\t”; return a < b ? b : a;
    }
    
    template <typename T>
    inline T const& max(T const& a, T const& b, T const& c){
        return max(max(a, b), c);
    }
    
    template<> // 特化
    const char* const& max(const char* const& a, const char* const& b){
        cout<<“2:\t”; return strcmp(a, b) < 0 ? b : a;
    }
    
    inline char const* max(char const* a, char const* b){
        cout<<“1:\t”; return std::strcmp(a, b) < 0 ? b : a;
    }
    
    int main(){
        int a = 5, b = 12;
        string s1 = "aString1", s2 = "aZtring2";
        const char* c1 = "hellow template override!";
        const char* c2 = "hellow C++ 11!";
        const char* c3 = "hellow everyone!";
        cout << max(7, 42, 32) << endl; //L1 ，输出 : 42
        cout << max(a, b) << endl; //L2 ，输出 : 12
        cout << max(s1, s2) << endl; //L3 ，输出 : aZtring2
        cout << max(c1, c2, c3) << endl; //L4 ，输出： hellow template override!
        cout << max(c1, c3) << endl; //L5 ，输出： hellow template override!
        }
```

### 4. 函数参数的匹配和调用次序
![](附件/Pasted%20image%2020260104004142.png)