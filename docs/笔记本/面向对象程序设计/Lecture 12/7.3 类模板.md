## 7.3.1 类模板的概念
类模板是 C++ 提供的另一种强大的编程工具。如果说函数模板是“函数的蓝图”，那么类模板就是“类的蓝图”。

简单来说，当你发现多个类的结构（成员变量）和行为（成员函数）完全一样，只有处理的数据类型不同时，就可以使用类模板。
![](附件/Pasted%20image%2020260102235858.png)

---

## 7.3.2 类模板的定义
```c++
    template <typename T1, typename T2, ...>
    class 类名 {
        // 类成员的声明与定义
    };
```

- T1, T2 是类型参数，代表未来会使用的具体数据类型。
- 类模板中同样可以包含非类型参数（如整数常量，用于指定数组大小）。

### 类模板的成员函数的定义
![](附件/Pasted%20image%2020260103002511.png)

### 设计一个堆栈的类模板 Stack ，在模板中用类型参数 T 表示栈中存放的数据，用非类型参数 MAXSIZE 代表栈的大小
```c++
    #include <iostream>
    using namespace std;

    // Declaration of the Class Template
    template <class T, int MAXSIZE>
    class Stack {
    private:
        T elems[MAXSIZE]; // Array to store elements of type T
        int top;          // Index for the top of the stack

    public:
        Stack() { top = 0; }
        void push(T e);
        T pop();
        bool empty() { return top == 0; }
        bool full() { return top == MAXSIZE; }
    };

    // Implementation of push member function
    template <class T, int MAXSIZE>
    void Stack<T, MAXSIZE>::push(T e) {
        if (top == MAXSIZE) {
            cout << "Stack full, cannot add more elements!" << endl;
            return;
        }
        elems[top++] = e; // Insert element and then increment top
    }

    // Implementation of pop member function
    template <class T, int MAXSIZE>
    inline T Stack<T, MAXSIZE>::pop() {
        if (top <= 0) {
            cout << "Stack empty, cannot pop elements!" << endl;
            return 0; // Note: Returning 0 might not work for all types T
        }
        return elems[--top]; // Decrement top and then return the element
    }
```

---

## 7.3.3 类模板实例化
1. 实例化包含的内容
    - 模板实例化和成员函数实例化：当你使用 `Stack<int 10>` 时，编译器不仅要生成这个类，还要生成它的成员函数（如`push和pop`）的具体代码
    - 这就意味着：编译器在实例化成员函数的那一刻，必须看到函数的源代码，如果源代码在`.cpp`文件中，当前编译的文件就找不到它，导致无法生成代码。
2. 实例化的时间
    - 当用类模板定对象时，引起类模板的实例化。也就是说实例化发生在编译阶段
    - 编译器的局限性：如果在编译main.cpp时遇到了对象定义，它需要立即查找模板的实现来生成具体的二进制代码。
3. 实例化的方式
    - 在实例化类模板的时候，如果模板参数时类型参数，则必须为它指定具体的类型；如果模板参数时非类型参数，则必须为它指定一个常量值。

### 实例化的案例：
如对Stack类模板，下面的定义将引起实例化：

`Stack<int, 10> iStack`

- 编译器实例化的方法：
    1. 数据成员实例化：将`Stack`模板声明中的所有数据成员的参数`T`替换成`int`，将所有非类型参数`MAXSIZE`替换成`10`，生成了一个`int`类型的类模板。
    2. 成员函数的实例化：
        - 用int类型替换无参构造函数中的T实例化出被调用的构造函数
        - 未被调用的成员函数不被实例化（即不生成相应的成员函数）

```c++
    class Stack{
    private:
        int elems[10];
        int top;    //栈顶指针
    public:
        Stack(){top=0;}    //入栈操作
        void push(int e);    //出栈操作
        int pop;
        bool empty(){
            return top==0;
        }
        bool full();
    }
```

---
## 7.3.4 类模板的使用
为了使用类模板，显示指定模板实参进行模板实例化
```c++
    #include<stack.h>
    #include<iostream>
    using std::cout;
    using std::endl;
    void main(){
        Stack<int, 10> iStack;
        Stack<char, 10> cStack;
        cout<<"-----intStack-----\n"
        int i;
        for(i=1;i<10;i++) iStack.push(i);
        for(i=1;i<10;i++) cout << iStack.pop() << "\t";
        
        cStack.push('A');
        cStack.push('B');
        cStack.push('C');
        cStack.push('D');
        cStack.push('E');
        for(i=1;i<6;i++) cout<<cStack.pop()<<"\t";
        cout<<endl;
    }
```

### 用之前建立的Stack模板编写一个函数display。该函数能够读取并显示Stack模板建立的栈中的所有元素（这个函数不是成员函数）
```c++
    #include<stack.h>
    #include<iostream>
    using namespace std;
    template <class T>
    void display(Stack<T, 10> & a){
        while(!s.empty())
            cout<<s.pop()<<"\t";
        cout << endl;
    }
```