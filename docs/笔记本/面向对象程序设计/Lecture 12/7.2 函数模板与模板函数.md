## 7.2.2 函数模板的实例化
![](附件/Pasted%20image%2020260102220117.png)
![](附件/Pasted%20image%2020260102220134.png)
![](附件/Pasted%20image%2020260102220155.png)
![](附件/Pasted%20image%2020260102220216.png)
`int i = max<int>(1, '2');`是强制告诉编译器把模板中的参数全都转移为 `int` 类型。此时的 `'2'` 就变为了50
![](附件/Pasted%20image%2020260102220351.png)

!!! example "example 3用函数模板实现数组的选择法排序"
```c++
    #include <iostream>
    using namespace std;

    // 1. 定义排序模板
    template <class T>
    void sort(T & a, int n) {
        for (int i = 0; i < n - 1; i++) {   // 外层循环控制轮数
            int p = i;
            for (int j = i + 1; j < n; j++) { // 内层循环找最大值下标
                if (a[p] < a[j]) {          // 降序判断
                    p = j;
                }
            } // 补齐内层循环的花括号

            // 关键修正：交换逻辑必须放在内层循环结束之后
            if (p != i) {
                int t = a[i];
                a[i] = a[p];
                a[p] = t;
            }
        } // 补齐外层循环的花括号
    }

    // 2. 定义显示模板（也必须重新写一次 template）
    template <class T>
    void display(T & a, int n) {
        for (int i = 0; i < n; i++) {
            cout << a[i] << "\t";
        } // 补齐循环花括号
        cout << endl;
    }

    int main() {
        int a[] = {1, 41, 2, 5, 8, 21, 23};
        char b[] = {'a', 'x', 'y', 'e', 'q', 'g', 'o', 'u'};

        // 隐式实例化调用
        sort(a, 7);
        sort(b, 8);

        display(a, 7);
        display(b, 8);

        return 0;
    }
```
![](附件/Pasted%20image%2020260102234040.png)
![](附件/Pasted%20image%2020260102234100.png)

![](附件/Pasted%20image%2020260102233819.png)

---

## 7.2.3 模板参数
![](附件/Pasted%20image%2020260102223707.png)
![](附件/Pasted%20image%2020260102223728.png)

- 上述代码会产生三个编译错误：`T max(T, T)`: 模板参数T不明确
- 在普通函数的调用过程中，C++会对类型不匹配的参数进行隐式的类型转换。但是，在模板实例化过程中不会进行任何形式的参数类型转换，从而导致模板函数的参数类型不匹配，因此产生上述编译错误。
![](附件/Pasted%20image%2020260102224033.png)

!!! example "例二、用两个模板参数实现求最大值的函数"
    ```c++
        include<iostream>
        using namespace std;
        template<class T1, class T2>
        T1 max(T1 a, T2 b){
            return a>b? a:b;
        }
        void main(){
            double a=2 , b=3.4;
            float c=5.1, d=3.2;
            cout << "2, 3.2的最大值是: " << max (2, 3.2);
            ...
        }
    ```
![](附件/Pasted%20image%2020260102234507.png)
### 1. 模板参数的作用域规则

- **起始点**：从 `template<...>` 声明开始。
- **终点**：直到该模板声明或定义的函数/类结束为止。
- 这也就是为什么你之前问“为什么要写两次 `template<class T>`”，因为第一个 `T` 的生命周期在第一个函数结束时就停止了。

### 2. 案例分析：隐藏外层同名名称
代码中定义了一个结构体 `struct A {};`。 但在函数模板 `void f(A a, B b)` 中：

- 这里的 `A` 不再是指那个结构体，而是模板参数 `typename A` 指定的 **任意类型** 。
- **隐藏现象**：在函数 `f` 内部，模板参数 `A` 隐藏了外层作用域定义的结构体类型 `A`。
    

### 3. 案例分析：不能重用参数名

代码中有一行错误示例：`int B;`。

- **错误原因**：`B` 已经被声明为模板参数名了。
- 在模板的作用域内，你不能再定义一个同名的变量、常量或类型。这就像你不能在同一个大括号内定义两个同名的局部变量一样。


---


