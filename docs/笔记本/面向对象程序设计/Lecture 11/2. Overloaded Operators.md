## Overloaded operators

#### 1. 单目和双目运算符 (Unary and binary operators)

- **算术和位运算：** `+`, `-`, `*`, `/`, `%`, `^`, `&`, `|`, `~`
- **赋值和复合赋值：** `=`, `<`, `>`, `+=`, `-=`, `*=`, `/=`, `%=`, `^=`, `&=`, `|=`, `<<=`, `>>=`
- **关系和逻辑：** `<<`, `>>`, `==`, `!=`, `<=`, `>=`, `!`, `&&`, `||`
- **增量和减量：** `++`, `--`
- **其他特殊运算符：** `,` (逗号运算符), `->*` (指针成员访问), `->` (成员访问), `()` (函数调用运算符), `[]` (下标运算符)
    

#### 2. 内存管理运算符

- **内存分配：** `operator new`, `operator new[]`
- **内存释放：** `operator delete`, `operator delete[]`

!!! explanation "函数重载"
    函数重载指的是定义多个名称相同但参数列表不同的函数。
    
    - 参数列表不同包括：
        - 参数的 **数量** 不同。
        - 参数的 **类型** 不同。
        - 参数的 **顺序** 不同。
        
    - 示例：
    ```c++
        void print(int i){}
        void print(double d){}
        void print(int i, int j){}
    ```
    调用 `print(10)` 时，编译器会选择接受 `int` 参数的那个版本。
    
    调用 `print(3.14)` 时，编译器会选择接受 `double` 参数的那个版本。

!!! explanation "运算符重载"
    
    运算符重载的核心思想是 **让符号为您的自定义类工作**，让自定义类（如 `Vector`, `ComplexNumber`）能够像内置类型一样直观地进行操作，提高代码的可读性和易用性。
    
    - 示例：
        - 为自定义的 `ComplexNumber` 类重载 `+` 运算符，使得 `ComplexNumber c3 = c1 + c2;` 能够执行复数相加。
        - 为自定义的容器类重载 `[]` 运算符，使得 `myContainer[index]` 能够像数组一样访问元素。
    
    如果我们有一个自定义的`Point`类，并且想用它作为`std::set`或`std::map`的键，那么我们必须重载`<`运算符。
    ```c++
        class Point {
            int x,y;
        public:
        //构造函数此处不多写了，反正只是举个例子
        //重载＜运算符号
        bool operator<(const Point &other) const{
            if (x!=other.x){
                return x<other.x;
            }
            return y<other.y;
        }
    ```

---
## Operators you can't overloaded

#### 1. 核心语言结构符号
这些符号被编译器用于处理语法结构或内存访问，其行为不允许更改：

- **`.` (点运算符)**：用于访问类的 **非静态成员** 。
- **`.*` (点星运算符)**：用于通过 **指向成员的指针** 访问成员。
- **`::` (作用域解析运算符)**：用于访问命名空间、类或全局作用域中的成员。
- **`?:` (条件运算符/三目运算符)**：用于条件表达式。
    
#### 2. 运行时和编译时关键字/运算符

这些关键字用于获取类型信息或处理内存，它们的行为是语言规范的一部分：

- **`sizeof`**：返回类型或对象在内存中占用的字节数。
- **`typeid`**：用于运行时类型识别 (RTTI)。
    
#### 3. C++ 类型转换运算符
这些是 C++ 中安全或不安全的类型转换操作符，它们的功能是固定的，不能被用户重定义：

- **`static_cast`**
- **`dynamic_cast`**
- **`const_cast`**
- **`reinterpret_cast`**

---

## Pointer to members

```c++
    #include<iostream>
    using namespace std;
    struct Myclass {
        int a;
        void hello(){
            cout << "Hello!" << endl;
        }
    };
    
    int main(){
        int Myclass::* ptr = & Myclass ::a; //指向成员变量a
        Myclass obj{42, 3.14};
        cout << obj.*ptr << endl;
        
        void(Myclass::*funcPtr)() = &Myclass::hello; //指向函数成员
        Myclass obj;
        
        (obj.*funcPtr)(); //通过对象调用成员函数
        return 0;
        
    }
```

---
## C++ overloaded operator

#### 1. 运算符重载的本质 (Just a function with an operator name!)

- **核心定义：** 运算符重载本质上 **就是一个带有运算符名称的函数** 。
- **实现方式：** 使用 `operator` 关键字作为前缀来命名这个特殊的函数。
    - **示例：** 如果要重载乘法符号 `*`，函数名就是 `operator*`。
        

#### 2. 实现形式：成员函数 (Can be a member function)

- **成员函数形式：** 重载运算符可以作为类的成员函数来实现。
- **隐式第一个参数：** 当运算符作为成员函数重载时，它会有一个 **隐式的第一个参数** ，即调用它的对象（通过 `this` 指针）。
    - **示例代码：** `String String::operator+(const String& that);`
        - 这个函数重载了 `+` 运算符，用于 `String` 类。
        - 当代码写成 `s3 = s1 + s2;` 时，它实际上被编译为 `s3 = s1.operator+(s2);`。
        - `s1` 是 **隐式** 的第一个操作数（通过 `this` 指针访问），`s2` 是作为参数 `that` 传入的第二个操作数。

#### 3. 全局函数形式 (Can be a global (free) function)

- **显式参数：** 当运算符作为非成员函数重载时， **所有的参数都是显式的** 。
- **示例代码：** `String operator+(const String& l, const String& r);`
- **调用方式：** 当您写 `s3 = s1 + s2;` 时，它被解释为 `s3 = operator+(s1, s2);`。`s1` 是第一个参数 `l`，`s2` 是第二个参数 `r`。

___

## Operators as member functions
```c++
    class Integer{
    public:
        Integer(int n = 0):i(n) {}
        Integer operator+(const Integer& n) const{
            return Integer(i+n.i);
        }
        ...
    private:
        int i;
    }
```

![](附件/Pasted%20image%2020251204002203.png)

- **Implicit first argument**（第一个参数是隐式的）
    - **解释：** 在 `x.operator+(y)` 中，`x` 是隐式的，通过 `this` 指针访问；只有 `y` 是作为显式参数传入的。
        
- **full access to all data**（成员可以完全访问类中的所有数据）
    - **解释：** 再次确认了代码中 `i` 和 `n.i` 的私有成员访问是合法的，因为它们在同一个类的成员函数内。
-  **No type conversion performed on receiver**（不会对接收者执行类型转换）
        1. `z = x + y;`： **正确**  (`x.operator+(y)`)。
        2. `z = x + 3;`： **正确**  (`x.operator+(Integer(3))`)。数字 `3` 被隐式转换为 `Integer` 对象。
        3. `z = 3 + y;`： **错误**  (`3.operator+(y)`)。内置类型 `int` 没有成员函数，且 **接收者 (`3`) 不会被转换** 为 `Integer` 对象，导致编译失败。

---

## Global operators
```c++
    class Interger{
    public:
        friend Integer operator+(const Integer&, const Integer&);
        ...
    private:
        int i;
    }
    Integer operator+(const Integer& lhs, const Integer& rhs){
        return Integer(lhss.i + rhs.i);
    }
```

- Binary operators require two arguments（双目运算符需要两个参数）
    - `+`, `-`, `*`, `/` 等运算符需要左侧和右侧两个操作数。当重载为全局函数时，这两个操作数都必须作为显式参数在函数签名中列出（例如：`operator+(lhs, rhs)`）。
- Unary operators require one argument（单目运算符需要一个参数）
    - `!` (逻辑非), `-` (取负), `++` (前缀/后缀自增) 等只需要一个操作数。当重载为全局函数时，这个操作数作为唯一的显式参数传入。
- Conversion（类型转换）：
    - 这是全局函数重载的核心优势，它解决了成员函数无法处理对称性的问题（刚刚那个成员函数只能执行`z=x+3`，而不能执行`z=3+x`，但是全局函数可以）
- ![](Pasted%20image%2020251204010121.png)
- If you don't have access to private data members, then the global function must use the public interface (e.g. accessors)（如果您没有权限访问私有数据成员，那么全局函数必须使用公共接口）
    - - **使用公共接口：** 在类中提供 `public` 的访问器（Getter 函数），让全局函数通过这些函数获取私有数据。
    - **使用友元 (`friend`):** 如图 `image_f3bcfc.png` 所示，在类内部将该全局函数声明为友元，赋予它直接访问私有成员的特权。

---

## The prototypes of operators（运算符原型）

#### 1. 算术和位运算符 (`+ - * / % ^ & | ~`)

- **涉及的运算符：** 加 (`+`)、减 (`-`)、乘 (`*`)、除 (`/`)、取模 (`%`)、位异或 (`^`)、位与 (`&`)、位或 (`|`)、位取反 (`~`)。
    - 注意：除 `~` (单目) 外，这些通常是 **双目运算符**。
- 原型：`T operator X(const T& l, const T& r);`
    - 返回类型 `T`，函数名 `operator X`，接受两个常量引用参数 `l` (左操作数) 和 `r` (右操作数)。
    - `T` 是操作数的类型（例如 `Integer`），`X` 代表具体的运算符符号。由于这些运算符通常返回一个新的值（例如 $3+5$ 返回 $8$），所以返回类型是 `T`。
        
#### 2. 关系和逻辑运算符 (`! && || < <= == >= >`)

- **涉及的运算符：** 逻辑非 (`!`)、逻辑与 (`&&`)、逻辑或 (`||`)、小于 (`<`)、小于等于 (`<=`)、等于 (`==`)、大于等于 (`>=`)、大于 (`>`)。
    - 注意：`!` (逻辑非) 是单目运算符，其他是双目运算符。
        
- 原型：`bool operator X(const T& l, const T& r);`
    
    - 返回类型 `bool`，函数名 `operator X`，接受两个常量引用参数 `l` 和 `r`。
    - 关系和逻辑运算符的目的是进行比较和判断，所以它们的返回类型通常是布尔值 (`bool`)，表示“是”或“否”。
        

#### 3. 下标运算符 (`[]`)

- **涉及的运算符：** 下标运算符 (`[]`)。
- 原型：`E& T::operator [](int index);`
    
    - 返回类型 `E&` (元素类型的引用)，作用于类型 `T` 的命名空间内 (`T::`)，函数名 `operator []`，接受一个整数索引 `index`。
    - **成员函数：** `operator []` 必须重载为成员函数，因为它通常用于访问类对象的内部数据（如数组或 `vector`）。 
    - **返回引用 (`E&`):** 返回值必须是元素的引用。这允许您将它用于读取 (`x = obj[i]`) 和写入(`obj[i] = y`) 两种操作。


