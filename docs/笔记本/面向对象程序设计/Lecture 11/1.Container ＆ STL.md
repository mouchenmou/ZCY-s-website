## What is STL ?
![](附件/Pasted%20image%2020251130212631.png)

---
## Why should I use STL ?
![](附件/Pasted%20image%2020251130212727.png)

---
## C++ Standard Library
#### 1. `pair` 类
- **A pair class (pairs of anything, int/int, int/char, etc)**
    - `std::pair` 是一个简单而强大的模板类，用于将两个不同或相同类型的值组合成一个单一的对象。
    - **用途：** 经常用于从函数返回两个值，或作为 `std::map` 中键值对的基本结构。
    - ![](附件/Pasted%20image%2020251130213843.png)
    - ![](附件/Pasted%20image%2020251130213910.png)

#### 2. Containers (容器)
容器是 STL 的核心，用于高效地存储和管理数据。

- **`vector` (expandable array)**
    -  动态数组。它允许在末尾快速插入和访问元素，并且可以自动增长大小。
- **`deque` (expandable array, expands at both ends)**
    - 双端队列。类似于 `vector`，但它支持在两端（前端和后端）快速插入和删除元素。
- **`list` (double-linked)**
    -  双向链表。它允许在列表的任何位置以常数时间 $O(1)$ 复杂度快速插入和删除元素，但随机访问（按索引访问）较慢。
- **`set` and `map`**
    - `set`：存储唯一的有序元素，用于快速查找。  
    - `map`：存储**键值对**（Key-Value pairs），键是唯一的，用于通过键快速查找对应的值。
            
#### 3. Basic Algorithms
- **Basic Algorithms (sort, search, etc)**
    - 标准库中的 `<algorithm>` 头文件提供了大量泛型算法，可以作用于不同的容器。
    - **用途：** 比如 `std::sort` (排序)、`std::find` (查找) 等，这些算法经过高度优化，且可以与所有 STL 容器配合使用。

#### 4. 命名空间约定
- **All identifiers in library are in `std` namespace**
    
    - * C++ 标准委员会将标准库中所有名称（如 `vector`, `sort`, `pair` 等）都放在了 `std` (standard 的缩写) 命名空间内，以防止与用户自定义的名称发生冲突。
    - **使用方式：**
        - 必须使用 `std::` 前缀来访问它们，例如 `std::vector`。
        - 或者使用 `using namespace std;` 语句来引入整个命名空间（尽管在大项目中通常不推荐这样做，因为它可能带来新的命名冲突）。

---

## 最常用的三种数据结构

#### 1. `map`（映射）

- **Any key type, any value type.** (任何键类型，任何值类型。)
    - `map` 存储键值对（Key-Value pairs）。键（Key）用于查找，值（Value）是存储的数据。它们可以是任何 C++ 类型。        
- **Sorted.** (有序的。)
    - `std::map` 内部通常由 **平衡二叉搜索树** （红黑树）实现，它根据键的顺序自动排序元素。这使得它支持高效的查找、插入和删除操作，时间复杂度通常为 $O(\log n)$。
            
- **用途：** 适用于需要根据唯一键快速查找对应值的情况，例如电话簿、字典、配置表等。
    

#### 2. `vector`（动态数组）
    
- **Like c array, but auto-extending.** (类似于 C 数组，但自动扩展。)
    - `vector` 是 C++ 中最常用的容器。它在内存中是**连续存储**的，像普通数组一样。   
    - 与 C 数组不同，当元素数量超过当前容量时，`vector` 会 **自动分配更大的内存** ，并将现有元素复制过去，实现“自动扩展”。
            
- **用途：** 适用于大多数需要高效**随机访问**（通过索引 $O(1)$ 访问）和在 **末尾快速添加** 元素的情况。
    

#### 3. `list`（链表）
    
- **doubly-linked list** (双向链表)
    - `std::list` 内部的每个元素都存储了指向**前一个**元素和**后一个**元素的指针。
    - 由于元素在内存中**不一定是连续的**，它不支持快速随机访问（通过索引访问速度慢）。
            
- **用途：** 适用于需要频繁在 **列表中间** 进行 **插入** 和 **删除** 操作的情况（这些操作的复杂度为 $O(1)$，非常快）。

---
## All Sequential Containers

#### 1. `vector` (动态数组)
- **特点：** 可变大小的数组 (`variable array`)。
- **内存：** 内存是连续存储的。
- **访问：** 支持快速的**随机访问**（通过索引 $O(1)$）。
- **增删：** 支持在**末尾**快速添加和删除元素。在中间插入或删除元素较慢（$O(n)$）。
    

#### 2. `deque` (双端队列)
- **特点：** 双端队列 (`dual-end queue`)。
- **内存：** 内存由多块连续存储区组成。
- **增删：** 支持在 **头部** 和 **尾部** 都进行快速的插入和删除操作。
- **访问：** 也支持随机访问，但通常比 `vector` 稍慢。
    

#### 3. `list` (双向链表)
- **特点：** 双向链表 (`double-linked-list`)。
- **内存：** 元素通过指针连接，在内存中不连续。
- **增删：** 支持在**任何位置**进行常数时间 $O(1)$ 的 **快速插入和删除** 操作。
- **访问：** 不支持快速随机访问（通过索引访问速度很慢）。
    

#### 4. `forward_list` (单向链表)
- **特点：** 单向链表 (`as it`)。
- **内存：** 比 `list` 更节省内存，因为它只存储指向下一个元素的指针。
- **增删：** 只支持从 **头部** 进行快速插入和删除。
- **用途：** 适用于只需要从头到尾顺序遍历的场景。
    

#### 5. `array` (静态数组)

- **特点：** 固定大小的数组 (`as "array"`)。
- **内存：** 内存是连续存储的。
- **大小：** 长度在 **编译时固定** ，不能动态改变。
- **用途：** 提供了 C 风格数组的效率，但具有标准库容器的安全性和功能（如支持迭代器）。
    

#### 6. `string` (字符串容器)
- **特点：** 字符数组 (`char array`)。
- **本质：** 专门用于存储字符序列的容器。
- **特性：** 行为上类似于 `vector<char>`，但提供了大量针对字符串操作的专用成员函数。

---

## Vector

- `vector` 是一种 **泛型类**。这种类需要指定两种类型，其中一个是容器自身的类型（这里是 `vector`），另一个是容器内元素的类型（上例中就是 `int`）
- `vector` 的内部空间可按需扩大：当有更多项被放入时，它就会为这些项提供足够的空间
- `vector` 会记录当前保存的项数，可以用 `size()` 方法读取
- `vector` 内部项的顺序即为项的插入顺序，因此可按相同的顺序检索
- 基本的运算：
    - 构造函数（Constructors）：
        - `vector<Elem> c;`
        - `vector<Elem> c1(c2);`
    - 获取大小：
        - `V.size()`：当前容器内项数
        - `V.empty()`：是否为空，相比 `.size()` 速度更快
        - `V.capacity()`：在当前分配的存储空间内最多可以存放的项数
    - 迭代器：
        - `I.begin()`：获取第一个位置
        - `I.end()`：获取最后一个位置
    - 元素访问：
        - `V.at(index)`
            - 该方法会进行边界检查，如果越界，编译器会抛出异常，更加安全
        - `V[index]`
            - 注意：不能用这种方法修改元素！
            - 该方法不会做边界检查，如果越界的话，则行为不可预测，是未定义的行为（Undefined Behaviour），因此速度快，但不安全
        - `V.front()`：第一项
        - `V.back()`：最后一项
    - 添加 / 删除 / 查找：
        - `V.push_back(e)`
        - `V.pop_back()`
        - `V.insert(pos, e)`，其中 `pos` 是迭代器变量
        - `V.clear()`：清空向量内所有元素
        - `find(first, last, item)`，其中 `first`、`last` 是迭代器变量，返回的是位于 `first` 和 `last` 之间的迭代器，如果没有找到的话则返回 `last`
    - 其他：
        - 支持比较运算符 `== != < > <= >=`
        - `V.swap(v2)`：交换

![](附件/Pasted%20image%2020251130221722.png)

### Example of Vector
```c++
    #include<iostream>
    #include<vector>
    using namespace std;
    
    void print_size(vector<int> &v){
        cout << "size: " << v.size() << " " << "capacity: " << v.capacity() << endl;
    }
    
    int main(){
        vector<int> v(151);
        v[10] = 10;
        print_size(v);
        
        v.push_back(10);
        print_size(v);
        
        v.resize(1000);
        print_size(v);
        
        v.reserve(2000);
        print_size(v);
        
        v.clear();
        print_size(v);
        
        v.shrink_to_fit();
        print_size(v);
        
        vector<int> v2(5);
        v2.swap(v);
        print_size(v);
        
        return 0;
    }
```

![](附件/Pasted%20image%2020251130222912.png)

!!! conception "## Two ways to use Vector"
    #### 1. Preallocate
    ```c++
        vector <int> v(100);
        v[80] = 1; //OK
        v[200] = 1; //Bad    
    ```
    #### 2. Grow tail
    ```c++
        vector<int> v2;
        int i;
        while (cin << i)
            v.push_back(i);
    ```
    方法二避免了溢出风险

___
## List
- **基本概念与 `vector` 相似：** `list` 与 `vector` 共享相同的基础概念，例如都有构造函数。
- **比较能力：** `list` 支持列表之间的比较操作符（`==`, `!=`, `<`, `<=`, `>`, `>=`）。
- **访问头尾：** 能够访问列表的头部和尾部。
    - `x.front()`：访问列表的第一个元素。
    - `x.back()`：访问列表的最后一个元素。
- **赋值与移除：** 支持向列表中赋值元素和移除元素。
    - `x.push_back(item)`：在列表的 **尾部** 添加元素。
    - `x.push_front(item)`：在列表的 **头部** 添加元素。
    - `x.pop_back()`：移除列表 **尾部** 的元素。
    - `x.pop_front()`：移除列表 **头部** 的元素。
    - `x.remove(item)`：移除列表中 **所有等于**  `item` 的元素。

![](附件/Pasted%20image%2020251203164504.png)
![](附件/Pasted%20image%2020251203164531.png)

### Example1 of List
```c++
    #include<iostream>
    #include<iterator>
    #include<list>
    #include<algorithm>
    using namespace std;
    
    int main(){
        list<int> L;
        for(int i = 1; i<=5; ++i){
            L.push_back(i);
        }
        L.erase(++L.begin());
        copy(L.begin(), L.end(), ostream_iterator<int> (cout, ","));
        return 0;
    }
```
![](附件/Pasted%20image%2020251203204609.png)

### Example2 of list
```c++
    #include<iostream>
    #include<string>
    #include<list>
    using namespace std;
    
    int main(){
        list<string> s;
        s.push_back("hell0");
        s.push_back("world");
        s.push_front("tide");
        s.push_front("crimson");
        s.push_front("alabama");
        
        list<string>::iterator p;
        for(p=s.begin(); p!=s.end(); p++){
            cout << *p << " ";
        }
        cout << endl;
        
        for(string tmp:s){
            cout << tmp << " ";
        }
        cout << endl;
        
        for(auto tmp:s){
            cout << tmp << " ";
        }
        cout << endl;
        
        return 0;
    }
```

![](附件/Pasted%20image%2020251203204915.png)

---
## Map

- Maps are collections that contain pairs of values.
- Pairs consist of a key and a value.
- Look up works by supplying a key, and retrieving a value.
    ![](附件/Pasted%20image%2020251203170416.png)
- An example: a telephone book.

### Example of Map
```c++
    map<long, int> root;
    root[4] = 2;
    root[1000000] = 1000;
    long l;
    cin << l;
    if(root.cout(l))
        cout<< root[l];
    else
        cout<<"Not perfect square";
```

---
## Iterators
`Iterator`(迭代器)是c++`STL`(标准模板库)中的一个核心概念，是一种泛型指针，用于统一访问不同容器（如`Vector`、`list`、`map`）中的元素。

#### 1. 声明迭代器 (Declaring)
- **代码：** `list<int>::iterator li;`
- **解释：** 声明一个名为 `li` 的迭代器。迭代器是 STL 的核心概念，它是一个泛型指针，用于按顺序访问容器（如 `list`、`vector` 等）中的元素。

#### 2. 容器的头部 (Front of container)
- **代码：** `li = L.begin();`
- **解释：** `L.begin()` 是 `std::list`（或其他 STL 容器）的成员函数，它返回一个指向容器中第一个元素的迭代器。
- **用途：** 这通常是遍历容器时的起始点。

#### 3. 容器的尾部之后 (Past the end)
- **代码：** `li = L.end();
- **解释：** `L.end()` 返回一个指向容器中最后一个元素之后的“哨兵”位置的迭代器。
- **用途：** 这个位置本身不包含任何有效数据，它仅作为遍历循环的结束条件。例如，遍历循环通常会持续到迭代器达到 `end()` 之前 (`it != L.end()`)。

#### 4. 可以自增
- **代码示例：**
    ![](附件/Pasted%20image%2020251203171900.png)
- **操作：** `++li` (自增操作)。
- **解释：** 迭代器的自增操作使其从当前指向的元素移动到下一个元素。在 `std::list` 中，这是通过跟随双向链表的下一个节点指针实现的。
    - 示例中，`li` 首先被初始化指向列表的第一个元素 (`L.begin()`)。
    - 接着 `++li` 使其指向列表的第二个元素。

#### 5. 可以解引用
- **代码示例：**
- `*li = 10;` 
- **操作：** `*li` (解引用操作)。
    
- **解释：** 解引用操作符 `*` 用于获取迭代器当前指向的元素的值。
    
    - 在 C++ 中，如果迭代器指向一个可修改的容器元素，您可以使用解引用操作符来修改该元素的值，就像修改普通指针指向的值一样。
        
    - 示例中，它将 `li` 当前指向的那个元素的值设置为 `10`。

---
## Algorithm

STL 算法（如 `copy`、`sort`、`find` 等）设计成不直接操作容器，而是通过接受 **迭代器** 作为参数来定义它们操作的元素范围。

```c++
    list<int> L;
    vector<int> V;
    // put list in vector
    copy(L.begin(), 
         L.end(), 
         V.begin());
```

- **`L.begin()` 和 `L.end()`：** 这两个迭代器定义了 **源范围**（ 要复制哪些元素）。`L.begin()` 指向 `list L` 的第一个元素，`L.end()` 指向 `L` 的末尾之后。
    
- **`V.begin()`：** 这个迭代器定义了 **目标起始位置** （复制到哪里开始）。它指向 `vector V` 的第一个元素。

---

## Typedefs

#### 1. 问题：冗长的名称 (Annoying to type long names)
当使用复杂的 STL 容器嵌套时，类型名称会变得非常长且难以阅读：
- **容器声明：** `map<Name, list<PhoneNum>> phonebook;`
- **迭代器声明：** `map<Name, list<PhoneNum>>::iterator finger;`

#### 2. 解决方案：使用 `typedef` 简化 (Simplify with typedef)
使用 `typedef` 可以为复杂的类型定义一个**简洁的别名**。
- **定义别名：** `typedef PB map<Name, list<PhoneNum>>;`
    - 这将 `map<Name, list<PhoneNum>>` 这个复杂的类型命名为 `PB`。
- **使用别名：**
    - `PB phonebook;`（使用别名声明容器）
    - `PB::iterator finger;`（使用别名声明迭代器，大大缩短了名称）

#### 3. 额外优势 (Easy to change implementation)
- `Easy to change implementation.` (容易更改实现)
    - **解释：** 如果您决定将底层实现从 `map` 换成 `unordered_map` 或其他结构，只需要修改一次 `typedef` 的定义。所有使用 `PB` 别名的地方都会自动更新，从而提高了代码的可维护性和灵活性。

---
## Using your own classes

当我们创建自定义 C++ 类时，为了让它们能够与标准库（特别是 STL 容器和算法）正常协作，需要额外实现的几个关键成员函数。

#### 1. 可能需要实现的基本成员函数 (Might need)
- **赋值运算符 (`Assignment Operator, operator=()`):**
    - **用途：** 当一个**已存在的**对象被赋给另一个对象时（例如 `a = b;`），这个函数会被调用。
    - **重要性：** 如果类管理着动态资源（如指针），您必须自定义这个运算符来实现 **深拷贝 **，同时处理资源释放和自我赋值检查。
- **默认构造函数 (`Default Constructor`):**
    - **用途：** 当对象在没有提供初始化参数的情况下被创建时（例如 `MyClass a;` 或在数组中创建对象时），这个函数会被调用。
    - **重要性：** 许多 STL 容器在预分配空间时需要内部元素的类型有一个可访问的默认构造函数。

#### 2. 排序类型所需的运算符 (For sorted types, like set, map,...)

对于那些底层需要对元素进行排序的 STL 容器（如 `std::set` 和 `std::map`）：
- **需要小于运算符 (`Need less-than operator: operator<()`):**
    - **用途：** 这些容器需要知道如何比较两个元素（或键）来确定它们的相对顺序。
    - **实现：** 如果您将自定义类的对象用作 `set` 的元素或 `map` 的键，您必须为您的类重载小于运算符 (`operator<`)。
- **自带默认比较的类型：**
    - **示例：** 像 `int`、`char` 和 `string` 这样的基本类型或标准库类型，已经默认实现了 `operator<`。
- **不自带默认比较的类型：**
    - **示例：** 像原始指针 `char *` 这样的类型，默认的比较是按 **内存地址** 进行比较，而不是按内容（字符串）进行比较，这通常不是我们想要的排序方式，所以需要自定义比较逻辑。

!!! example "Example of user-defined type"
    - Sorted container needs sort function.
    
    ```c++
        #include<iostream>
        #include<map>
        #include<string>
        #include<cstring>
        using namespace std:
        
        struct full_name{
            char * first;
            char * last;
            bool operator<(full_name & a) const {
                int firstCompare = strcmp(first, a.first);
                if(firstCompare != 0){
                    return firstCompare < 0;
                }
                else{
                    return strcmp(last, a.last) < 0;
                }
            }
        };
        using PB = map<full_name, int>;
        
        int main(){
            PB phonebook;
            
            full_name johnName = {"John", "Doe"};
            full_name JaneName = {"Jane", "Doe"};
            phonebook[johnName] = 123456789;
            phonebook[janeName] = 987654321;
            
            full_name searchName = {"John", "Doe"};
            
            if(phonebook.find(searchName) != phonebook.end()){
                cout << "Found John's number: " << phonebook(searchName) << endl;
            }
            else{
                cout << "John's number not found" << endl;
            }
            
            for(const auto & entry : phonebook){
                cout << entry.first.first << " " << endl;
            }
            return 0;
        }
    ```

---
## Pitfalls

!!! warning  "1. 访问无效元素 (Accessing an invalid vector<> element)"
    
    ```c++
        vector<int> v;
        v[100]=1; // Whoops!
    ```

    - `vector<int> v;` 声明了一个空的 `vector`，它的当前size是0。
    - 尝试使用下标运算符 `v[100]` 对第 101 个元素进行赋值，是一种越界访问。   
    - **问题：** 下标运算符 `[]` 不会检查边界，它假设您知道该元素是存在的。当您访问一个不存在的元素时，这会导致未定义行为，通常是程序崩溃。
        
    #### 解决方案

    - 使用 `push_back()`)
    - `Preallocate with constructor.` (使用构造函数预分配)
    - `Reallocate with resize()` (使用 `resize()` 重新分配大小):
    - `Check size()` (检查大小):

!!! warning "2. 意外插入"
    
    ```c++
        if (foo["bob"]==1) // silently created entry "bob"
    ```
    
    - 当我们使用下标运算符 `[]` 访问 `std::map` 中不存在的键时（例如 `foo["bob"]`），`std::map` 会**自动**（或称“静默地”）将该键插入到 `map` 中。
    - 插入的值是**值类型**的默认值（例如，如果值是 `int`，则插入 0）。
    - 因此，即使您的意图只是**检查**键是否存在，这段代码也会**创建**一个名为 `"bob"` 的新条目。
    
    #### 解决方案
    
    - 使用 `count()` (C++ 98/03/11/14/17):
        - 代码： `if (foo.count("bob"))`
        - 目的： `count()` 函数会返回 `map` 中该键的出现次数（对于 `std::map`，结果只能是 0 或 1）。它只检查键是否存在，而不会创建新的条目。
    - 使用 `contains()` (C++ 20 引入):
        - 代码： `if (foo.contains("bob"))`
        - 目的： `contains()` 是 C++20 引入的一个更清晰的成员函数，它的作用与 `count()` 相同，即只检查键是否存在，但返回一个布尔值 (`true`/`false`)。

!!! warning "3. 在检查 `std::list` 是否为空时，应该使用哪个成员函数来获得最佳性能？"
    
    #### 1. 慢速方法：使用 `size()` (Slow)
    - `if (my_list.size() == 0) { ... }`
        - 对于 `std::list` 这种双向链表结构，为了准确返回列表的元素总数，`size()` 函数可能需要遍历整个列表来计数。
        - 时间复杂度为$O(N)$
    
    #### 2. 快速方法：使用 `empty()` (Fast)
    - `if (my_list.empty()) { ... }`
        - `empty()` 函数只需要检查内部的头尾指针是否相等，或者检查一个内部计数器是否为零。
        - 时间复杂度为1

!!! warning "4. 使用无效迭代器的陷阱 (Pitfalls: Using invalid iterator)"
    
    ```c++
        list<int> L;
        list<int>::iterator li;
        li = L.begin();
        L.erase(li);
        ++li; // WRONG
    ```
    
    - 当调用 `L.erase(li)` 时，`li` 所指向的元素被从列表中移除并销毁。
    - 在元素被移除后，迭代器 `li` 立即变为无效（invalid），因为它指向的内存位置已经不再是列表的一部分。
    
    #### 解决方案：使用 `erase` 的返回值 (Use return value of erase)
        
    - li = L.erase(li); // RIGHT
        - `std::list::erase()` 函数在移除元素后，会返回一个指向被移除元素下一个元素的有效迭代器。
