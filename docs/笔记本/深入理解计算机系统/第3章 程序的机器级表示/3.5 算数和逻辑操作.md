# 3.5 算数和逻辑操作
下表列出了x86-64的一些整数和逻辑操作。大多数操作都分成了指令类，这些指令类有各种带不同大小操作数的变种（只有leaq没有其它大小的变种）。例如指令类ADD由四条加法指令组成：

- addb：字节加法
- addw：字加法
- addl：双字加法
- addq：四字加法

事实上，给出的每个指令类都有四种不同大小数据的指令。这些操作被分为四组：

- 加载有效地址
- 一元操作    //只有一个操作数
- 二原操作    //有两个操作数
- 移位


| 操作类型   | 指令           | 效果                  | 描述     |
| ------ | ------------ | ------------------- | ------ |
| 加载有效地址 | $leaq\ S, D$ | $D \leftarrow \& S$ | 加载有效地址 |
| 一元操作   | $INC\ D$     | $D ← D + 1$         | 加1     |
| 一元操作   | $DEC\ D$     | $D ← D - 1$         | 减1     |
| 一元操作   | $NEG\ D$     | $D ← - D$           | 取负     |
| 一元操作   | $NOT\ D$     | $D ← ~D$            | 取正     |
| 二元操作   | $ADD\ S, D$  | $D ← D + S$         | 加      |
| 二元操作   | $SUB\ S, D$  | $D ← D - S$         | 减      |
| 二元操作   | $IMUL\ S, D$ | $D ← D * S$         | 乘      |
| 二元操作   | $XOR\ S, D$  | $D ← D \wedge S$    | 异或     |
| 二元操作   | $OR\ S, D$   | $D ←D \vert S$      | 或      |
| 二元操作   | $AND\ S, D$  | $D ← D \& S$        | 与      |
| 移位     | $SAL\ k, D$  | $D ← D << k$        | 左移     |
| 移位     | $SHL\ k, D$  | $D ← D >>k$         | 右移     |
| 移位     | $SAR\ k ,D$  | $D \gg_A S$         | 算数右移   |
| 移位     | $SHR\ k, D$  | $D \gg_L S$         | 逻辑右移   |

---

## 3.5.1 加载有效地址
加载有效地址指令leaq实际上是movq指令的变形。它的指令形式是从内存读数据到寄存器中，但实际上 **它根本就没有引用内存**，而是将有效地址写入到目的操作数。
!!! example
    我们用c语言的地址操作符 $\&S$ 说明这种计算。这条指令可以为后买你的内存引用产生指针。另外，它还可以简洁地描述普通的算术操作。例如，如果寄存器 $\%rdx$ 的值为x，那么指令 $leaq 7(\%rdx, \%rdx, 4), \%rax$ 将会把寄存器 $\%rax$ 的值设置成 $7+x+4x$ 

!!! tips
    为了说明leaq在编译出的代码中的使用，来看看下面这个c程序：
    ![](附件/Pasted%20image%2020251007223832.png)
    编译时，该函数的运算以3条leaq指令实现：
    ![](附件/Pasted%20image%2020251007223918.png)
    
    至于为什么要进行这么麻烦的操作而不是直接让 $rdx*12$ 是因为比例因子 $s$ 只能为1，2，4，
    8。

---

## 3.5.2 一元和二元操作
!!! tips "一元操作"
    只有一个操作数，这个数既是源也是目的。这个操作数可以是一个寄存器，也可以是一个内存位置。
    ![](附件/Pasted%20image%2020251007225255.png)

!!! tips "二元操作"
    第二个操作数既是源也是目的。第一个操作数可以是立即数、寄存器或是内存位置，第二个操作数只能是寄存器或内存位置。当第二个操作数为内存位置时，处理器必须从内存中读出值，执行操作，再把结果写回内存。
    ![](附件/Pasted%20image%2020251007225639.png)

!!! example
    ![](附件/Pasted%20image%2020251007231451.png)
    
	- 第二条语句中，rax所在的地址+8后即为0x108，因此这个操作的意思是将0x108这个地址指向的值减3
    
	- 第三条语句中，需要将16转化为16进制，也就是0x10。0x10+0x100=0x110，因此这个操作的意思是
	**0x110这个地址指向的值+1**，也就是 **0x14变为0x15**。

---

## 3.5.3 移位操作

!!! conception
    先给出移位量，再给出要移位的数。可以进行算数和逻辑右移。移位量可以是一个立即数，或者放在单字节寄存器 $\%cl$ 中。（这些指令很特别，因为只允许以这个特定的寄存器为操作数。）原则上来说，1个字节的移位量使得移位量的编码范围可以达到 $2^8-1=255$ 。x86-64中，移位操作对w位长的数据值进行操作，移位量是由 $\%cl$ 寄存器的低m位决定的，这里 $2^m=w$ 。高位会被忽略。所以，当寄存器 $\%cl$ 的16进制值为 $0xFF$ 时，指令 $salb$ 会移$7$位，指令$salw$会移$15$位，指令$sall$会移$31$位，而指令$salq$会移$63$位
!!! explanation "explanation1：一个字节的位移量可以使编码范围达到255"
    一个8位的组合可以表示多少种不同的数字或信息？
    
	- 最小的数字（所有位都是0）：$0000\ 0000_{2}=0$
	- 最大的数字（所有位都是1）：$1111\ 1111_{2}=255$
	
	这个0~255就是这个字节的编码范围

!!! explanation "explanation2：最大有效移位量"
    最大有效移位量是 $w−1$ 的原因在于 **移位的本质** 以及 **防止数据丢失或操作无效化** 的考虑。这里的 $w$ 代表数据的 **位长** ，也就是一个数有多少个二进制位，我们以一个 $w=8$ 位的字节为例来进行说明。
    
    假设我们的原始8位数据是：$A_{7}A_{6}A_{5}A_{4}A_{3}A_{2}A_{1}A_{0}$
    
    那么左移7位已经是极限，因为如果移动8位的话那就变成 $0000\ 0000$ 了
!!! explanation "explanation3：$\%cl为0xFF$ 时的移位量"
    ∵$0xFF$ 转化成2进制为 $1111\ 1111$
    
    又∵移位量是由 $%cl$ 的前 $m$ 位决定的
    
    ∴当 $w=8$，$m=3$ 时，会取 $%cl$的前3位作为位移量
    
    ∵$2^0+2^1+2^2=7$ 
    
    ∴$salb$会位移7位，其它的操作以此类推，下表中已呈现
!!! explanation "Table"
    ![](附件/Pasted%20image%2020251007234147.png)


![](附件/Pasted%20image%2020251007233448.png)

- 左移的两个操作的效果是等价的，都是将右边填上0。
- 右移的两个操作有区别
    - SAR执行算数移位：填上符号位
    - SHR执行逻辑移位：填上0
- 移位操作的目的操作数可以是一个寄存器或一个内存位置。

!!! example
    ![](附件/Pasted%20image%2020251008002617.png)
    上图中的edi位rdi的低32位，因此存放在edi中的数也都存放在rdi中
    ```
        salq $4, %rax：将rax左移4位，即✖16
    ```