# 3.4 访问信息
## 计算机内部的存储结构：
![](附件/Pasted%20image%2020251007144759.png)
一个x86-64的中央处理单元（CPU）包含一组16个存储64位值的通用目的寄存器。这些寄存器用来存储整数数据和指针。寄存器的本质就是存储空间。

%rax是x86-64这个体系结构中的16个寄存器之一，它的大小（存储空间）是8个字节（64位）。因此16个寄存器的总的存储空间就是16*8byte。

有的时候这多么内存太多了，我们就取低32位来用（高32位闲置了），低32位称为eax，ax和al，以此类推，如下图所示：
![](附件/Pasted%20image%2020251007145335.png)

以下为x86_64的16个通用寄存器(每个都能存储8个byte)：
![](附件/Pasted%20image%2020251007145631.png)

---
## 寄存器的发展史
### 8086（早期的机器）的8个通用寄存器：
它们都只有2个字节
![](附件/Pasted%20image%2020251007145715.png)

### 32位机器时代：
原来的8086的东西都能在者个32位的机器上跑
![](附件/Pasted%20image%2020251007145811.png)

### x86-64：
![](附件/Pasted%20image%2020251007145849.png)

!!! tips
    寄存器的首字母：
    
    r开头：64位
    
    e开头：32位
    
    比方我用int的时候（int只有4个字节）就只需要用到32位

---

## 寄存器的用途
每个寄存器都有各自的用途

- caller：调用者
- callee：被调用者
![](附件/Pasted%20image%2020251007150254.png)
- rax用来记录函数的返回值
- rdi，rsi，rdx和rcx都是用来传递参数的。

---

## 3.4.1 操作数指示符
- 以$开头的数称为立即数
- 以%开头的数称为寄存器
    - 下表中用符号 $r_{a}$ 来表示任意寄存器a，用引用 $R[r_{a}]$ 来表示它的值。这是将寄存器集合看成一个数组R，用寄存器标识符作为索引。
- 以括号+寄存器（比如 $(\%rdi)$ 这样的）称之为内存引用
    - 内存引用会根据计算出来的地址（有效地址）访问某个内存位置
    - 我们用符号 $M_{b}[Addr]$ 表示对存储在内存中从地址Addr开始的b个字节值的引用。为了简便，我呢通常省去下标b。

下表中展现了多种不同的寻址模式，表中底部用语法 $Imm(r_{b}, r_{i}, s)$ 表示的是最常用的形式。这样的引用有4个组成部分：

- $Imm$ ：立即数偏移
- $r_{b}$ ：基址寄存器
- $r_{i}$ ：变址寄存器
- $s$ ：比例因子
!!! tips "注意"
    比例因子s必须是1，2，4或8
    
    基址寄存器和变址寄存器必须是64位寄存器
有效地址被计算为 $Imm+R[r_{b}]+R[r_{i}]*s$

| 类型  | 格式                     | 操作数值                         | 名称         |
| --- | ---------------------- | ---------------------------- | ---------- |
| 立即数 | $$Imm$                 | $Imm$                        | 立即数寻址      |
| 寄存器 | $r_{a}$                | $R[r_{a}]$                   | 寄存器寻址      |
| 存储器 | $Imm$                  | $M[Imm]$                     | 绝对寻址       |
| 存储器 | $(r_{a})$              | $M[R[r_{a}]]$                | 间接寻址       |
| 存储器 | $Imm(r_{b})$           | $M[Imm+R[r_{a}]]$            | （基址+偏移量）寻址 |
| 存储器 | $(r_{b},r_{i})$        | $M[R[r_{b}]+[r_{i}]]$        | 变址寻址       |
| 存储器 | $Imm(r_{b}, r_{i})$    | $M[Imm+R[r_{b}]+R[r_{i}]]$   | 变址寻址       |
| 存储器 | $(, r_{i}, s)$         | $M[R[r_{i}]*s]$              | 比例变址寻址     |
| 存储器 | $Imm(, r_{i}, s)$      | $M[Imm+R[r_{i}]*s]$          | 比例变址寻址     |
| 存储器 | $(r_{b}, r_{i}, s)$    | $M[R[r_{b}]+R[r{i}]*s]$      | 比例变址寻址     |
| 存储器 | $Imm(r_{b}, r_{i}, s)$ | $M[Imm+R[r_{b}]+R[r_{i}]*s]$ | 比例变址寻址     |

---

## 3.4.2 数据传输指令

| Operation code（操作码） | Operands（操作数）    |
| ------------------- | ---------------- |
| movq                | $(\%rdi), \%rax$ |
| addq                | $$8, \%rsx$      |
| subq                | $\%rdi, \%rax$   |
| xorq                | $\%rsi, \%rdi$   |

### mov
mov的实质就是把数据从一个地方搬运到另一个地方，即读取一个数据然后把它运走。
!!! tips "mov的雷区"
    mov指令不能把一个地址里面的数搬运到另一个地址里面，就是没法从一个memory搬运到另一个memory中。也就是说mov指令的源操作数和目的操作数不能同时是一个地址。
    
    因此$mov (\%rax), (\%rbx)$这条指令是错误的
    
    如果想要把一个地址里面的数据搬运到另一个地址里面，必须进行两次mov
    ![](附件/Pasted%20image%2020251007170316.png)

!!! tips "mov的几种操作"
    ![](附件/Pasted%20image%2020251007170459.png)

### 下面两幅图记录的是两类数据移动指令
#### 如果说源操作数的位数跟目的操作数的位数不同（目的操作数更大），那么需要进行以下操作：
!!! tips "无符号的zero-extending"
    z的意思是补充0
    ![](附件/Pasted%20image%2020251007174218.png)

!!! tips "有符号的sign-extending"
    ![](附件/Pasted%20image%2020251007174247.png)

#### 这些操作本质上就是c语言中的int，float，double这些数据类型的转换。
#### 还有很多指令没法一一记住，可以访问[x86-64常用指令总结](https://blog.csdn.net/weixin_45937291/article/details/127876305)。
---
## 3.4.3 数据传送指令
!!! tips "exchange函数的c语言以及汇编语言的实现"
    ![](附件/Pasted%20image%2020251007170627.png)
    
	- 过程参数xp与y分别存放在寄存器%rdi和寄存器%rsi中。
	- 指令2从内存中读取出x并把它存放到rax这个寄存器中。
	- 寄存器rax就是用来返回函数值的。
	- 指令3将y写入到寄存器rdi中xp指向的内存位置。
	- $movq (\%rdi), \%rax$（指令2）：把rdi这个寄存器中存放的数（这个数是个地址）指向的值转移到rax这个寄存器中。
	
        - $(\%rdi)$：首先我们需要知道 $rdi$ 这个寄存器中存放的是一个地址a，那么 $(\%rdi)$ 的意思就是取出地址a指向的值。
    - 关于这段汇编代码值得注意的有两点：
        - c语言中所谓 “指针” 其实就是地址。间接引用指针就是将指针放在一个寄存器中，然后在内存引用中使用这个寄存器。
        - 像x这样的局部变量通常是保存在寄存器中的，而不是内存中。因为访问寄存器比访问内存要快得多。

---

## 3.4.4 压入和弹出栈数据
### 栈
- 栈就是内存中一块特殊区域，是一种数据结构。
- 栈的生长方向是从**高地址往低地址**生长（与堆相反）。
- 栈可以添加或删除值，不过要遵循先进后出的原则。
    - 通过 $push$ 操作把数据压入栈中。
    - 通过 $pop$ 操作删除数据。
    - 弹出的值永远是最近被压入并且仍然在栈中的值。
- 栈可以实现为一个数组，总是从数组的一端插入或删除元素，这一端被称为 **栈顶**。

!!! example "$push$"
    $pushq\ \%rax$：表示把rax这个寄存器力保存的那个数放到内存里。
    
    $pushq\  \%rax$ 有一个等价的操作，需要两步才能完成，具体如下：
    
    1.    $subq\ \$8, \%rsp$（rsp始终指向栈顶）//开辟一个新的内存空间
    
    2.    $movq\ \%rax, (\%rsp)$  //将rax这个寄存器里面的值转移到新的栈顶中
    ![](附件/Pasted%20image%2020251007205652.png)

!!! example "pop"
    $popq\ \%rbx$：把rsp中的数转移到rbx中，然后再把栈顶往上抬高。
    
    $popq\ \%rbx$同样也有一个需要两步才能完成的等价操作，具体如下：
    
    1.    $movq\ (\%rsp), \%rbx$ //把栈顶中的值转移到 $rbx$ 这个寄存器中
    
    2.    $addq\ \&8, \%rsp$ //把这个栈顶删除
    
    ps：这个操作并没有把原先的栈顶中的那个数给抹除掉，只是把它从这个栈中移出了，只有当新的数据被
    存储到 $rbx$ 这个寄存器中时，原先的那个数据才会真正被抹除。
