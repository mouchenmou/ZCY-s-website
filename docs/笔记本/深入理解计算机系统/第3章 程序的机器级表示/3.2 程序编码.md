# 3.2 程序编码
![](附件/Pasted%20image%2020251006132440.png)
假设一个c语言程序有两个文件main.c和mstore.c，现在用unix命令行编译这些代码：
```
    linux> gcc -Og -o prog main.c mstore.c
```

- 命令gcc就是用GCC C编译器，因为这是Linux的默认编辑器
- -Og告诉编译器使用会生成符合原始c代码整体结构的机器代码的优化等级。使用较高级别优化产生的代码会严重变形，以至于产生的机器代码和初始代码之间的关系非常难以理解。
- -o是生成的可执行文件（prog是文件名称），-o prog的意思就是生成一个名为prog的可执行文件

---

## 3.2.1 机器级代码
正如在1.9.3节中讲过的那样，计算机系统使用了多种不同形式的抽象，利用更简单的抽象模型来隐藏实现的细节。对于机器级编程来说，其中两种抽象尤为重要。

第一种是由 **指令集体系结构或指令集架构（ISA）** 来定义机器级程序的格式和行为，它定义了处理器状态、指令集格式，以及每条指令对状态的影响。大多数ISA，包括x86-64，将程序的行为描述成好像每条指令都是按顺序执行的，一条指令结束后，下一条指令再开始。处理器的硬件远比描述的精细复杂，它们并发地执行许多指令，但是可以采取措施保证整体行为与ISA指定的顺序执行的行为完全一致。

第二种抽象是，机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来，这将会在第9章中讲到。

在整个编译过程中，编译器会完成大部分的工作，将把用c语言提供的相对比较抽象的执行模型表示的程序转化成处理器执行的非常基本的指令。汇编代码表示非常接近于机器代码。与机器代码的二进制格式相比，汇编代码的主要特点是它用可读性更好的文本格式表示。能够理解汇编代码以及它与原始C代码的联系，是理解计算机如何执行程序的关键一步。

x86-64的机器代码和原始的C代码差别非常大。一些通常对C语言程序员隐藏的处理器状态都是可见的：

- 程序计数器(通常称为PC，在x86-64中用%rip表示)给出将要执行的下一条指令在内存中的地址。
- 整数寄存器文件包含16个命名的位置，分别存储64位的值。这些寄存器可以存储地址（对应于c语言中的指针）或整数数据。有的寄存器被用来记录某些重要的程序状态，而其它的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。
- 条件码寄存器保存着最近执行的算数或逻辑指令，它们用来实现控制或数据流中的条件变化，比如说用来实现if和while语句。
- 一组向量寄存器可以存放一个或多个整数或浮点数值。

虽然c语言提供了一种模型，可以在内存中声明和分配各种数据类型的对象，但是机器代码只是简单地将内存看成一个很大的、按字节寻址的数组。c语言中的聚合数组类型，例如数组和结构，在机器代码中用一组连续的字节来表示。即使是对标量数据类型，汇编代码也不区分有符号或无符号整数，不区分各种类型的指针，甚至不区分指针和数组。

程序内存包含：程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的内存块（比如说用malloc库函数分配的）。正如前面提到的，程序内存用虚拟地址来寻址，在任意给定的时刻，只有有限的一部分虚拟地址被认为是合法的。例如x86-64的虚拟地址是由64位的字来表示的。在目前的实现中，这些地址的高16位必须设置为0，所以一个地址实际上能够指定的是$2^{48}$或256TB范围内的一个字节。较为经典的程序只会访问几兆字节或几千兆字节的数据。操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。

一条机器指令只执行一个非常基本的操作，例如，将放在寄存器中的两个数字相加，在存储器和寄存器之间传送数据，或是条件分支转移到新的指令。编译器必须产生这些指令的序列，从而实现像算术表达式、循环或过程调用和返回这样的程序结构。

!!! tips "不断变化的生成代码的格式"
    在本书的表述中，我们给出的代码是由特定版本的GCC在特定的命令行选项设置下产生的。如果你在自己的机器上编译代码，很有可能用到其他的编译器或者不同版本的GCC，因而会产生不同的代码。支持GCC的开源社区一直在修改代码产生器，试图根据微处理器制造商提供的不断变化的代码规则，产生更有效的代码。
    本书示例的目标是如何查看汇编代码，并将它反向映射到高级编程语言中的结构。我们需要将这些技术应用到特定的编译器产生的代码格式上

---

## 3.2.2 代码示例
加入我们写了一个c语言代码文件mstore.c，包含如下的函数定义：
```c
    long mult2(long, long);
    void mulstore(long x, long y, long *dest){
        long t = mult2(x, y);
        *dest = t;
    }
```

在命令行中使用 "-S" 就能看到c语言编译器产生的汇编代码
```
    linux>gcc -Og -S mstore.c
```
这个指令会使GCC运行编译器，产生一个汇编文件 "mstore.s" ，但是不会做其它进一步的工作（通常情况下，它还会继续调用汇编器产生目标文件代码）。

汇编代码文件包含各种声明，包括下面几行：
```
    multstore:
        pushq    %rbx
        movq     %rdx, %rbx
        call     mult2
        movq     %rax, (%rbx)
        popq     %rbx
        ret
```
上面代码中每个缩进去的行都对应于一条机器指令。比如，pushq指令表示应该将寄存器%rbx的内容压入程序栈中，这段代码中已经除去了所有关于局部变量或数据类型的信息。

如果我们使用 "-c" 命令行选项，GCC会编译并汇编该代码：
    ```
        linux> gcc -Og -c mstore.c
    ```
这就会产生目标文件代码mstore.o，它是二进制格式的，所以无法直接查看。1368字节的文件mstore.o中有一段14字节的序列，它的16进制表示为：
    53 48 89 d3 e8 00 00 00 00 48 49 03 5b c3
这就是上面列出的汇编指令对应的目标代码。从中得出一个重要信息，即机器执行的程序只是一个字节序列，它是对一系列指令的编码。机器对产生这些指令的源代码几乎一无所知。
!!! tips "如何展示程序的字节表示"
    要展示程序（比如说mstore）的二进制目标代码，我们用反汇编器确定该过程的代码长度是14字节。然后，在文件mstore.o上运行GNU调试工具GDB，输入命令：
        ```
            (gdb) x/14xb multstore
        ```
    这条命令告诉GDB显示（简写为 'x'）从函数multstore所处地址开始的14个16进制格式表示（也简写为 'x'），的字节（简写为 'b'）。你会发现，GDB有很多有用的特性可以用来分析机器级程序，我们会在3.10.2中讨论。

要查看机器代码文件的内容，有一类称为反汇编器的程序非常有用。这些程序根据机器代码产生一种类似于汇编代码的格式。在Linux系统中，带 "-d" 的命令行标志的程序可以充当这个角色：
```
    linux> objdump -d mstore.o
```
结果如下：
```
    Disassembly of function multstore in binary file mstore.o
1   0000000000000000 <multstore>
    Offset    Byte              Equivalent assembly language
2      0:     53                push    %rbx
3      1:     48 89 d3          mov     %rdx, %rbx
4      4:     e8 00 00 00 00    callq   9 <multstore+0x9>
5      9:     48 89 03          mov     %rax, (%rbx)
6      c:     5b                poq     %rbx
7      d:     c3                retq
```
在左边，我们看到按照前面给出的字节顺序排列的14个十六进制字节值，它们分成了若干组，每组有1~5个字节。每组都是一条指令，右边是等价的汇编语言。

其中一些关于机器代码和它的反汇编表示的特性值得注意：

- x86-64的指令长度从1到15个字节不等。常用的指令以及操作数较少的指令所需的字节数少，而那些不太常用或操作数较多的指令所需字节数较多。
- 设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令。例如，只有指令pushq %rbx是以字节值53开头的。
- 反汇编器只是基于机器代码文件中的字节顺序来确定汇编代码。它不需要访问该程序的源代码或汇编代码。
- 反汇编器使用的指令命名规则与GCC生成的汇编代码使用的有些细微的差别。在我们的示例中，它省略了很多指令结尾的 "q" 。这些后缀是大小指示符，在大多数情况中可以省略。相反，反汇编器给call和ret指令添加了后缀 "q" ，同样，省略这些后缀也没有问题。

生成实际可执行代码需要对一组目标代码文件运行链接器，而这一组目标代码文件中必须含有一个main函数。假设在文件main.c中有下面这样的函数：
```c
    #include<stdio.h>
    void multstore(long, long, long *)
    int main(){
        long d;
        multstore(2, 3, %d);
        printf("2*3 --> %ld\n", d);
        return 0;
    }
    long mult2(long a, long b){
        long s = a * b;
        return s;
    }
```
然后我们用如下方法生成可执行文件prog：
```
    linux> gcc -Og -o prog main.c mstore.c
```
文件prog变成了8655个字节，因为它不仅包含了两个过程的代码，还包含了用来启动和终止程序的代码，以及用来与操作系统交互的代码。我们也可以反汇编prog文件：
```
    linux> objdump -d prog
```
反汇编器会抽取出各种代码序列，包括下面这段：
```
    Disassembly of function sum multstore binary file prog
1   0000000000400540 <multstore>
2     400540:  53                   pushq   %rbx
3     400541:  48 89 d3             mov     %rdx, %rbx
4     400544:  e8 42 00 00 00       callq   40058b <mult2>
5     400549:  48 89 03             mov     %rax, (%rbx)
6     40054c:  5b                   pop     %rbx
7     40054d:  c3                   retq
8     40054e:  90                   nop
9     40054f:  90                   nop
```
这段代码与mstore.c反汇编产生的代码几乎完全一样。其中一个主要的区别是左边列出的地址不同——链接器将这段代码的地址移到了一段不同的地址范围中。第二个不同之处在于链接器填上了callq指令调用函数mult2需要使用的地址（反汇编代码第4行）。多了两行代码（第8和9行）。这两条指令对程序没有影响，因为它们出现在返回指令之后，插入这些指令是为了使函数代码变为16个字节，使得就存储器系统性能而言，能更好地放置下一个代码块。

---
## 3.2.3 关于格式的注解
GCC产生的汇编代码对我们来说有点难读。一方面，它包含了一些我们不需要关心的信息，另一方面，它不提供任何程序的描述或它是如何工作的描述。例如，假设我们用如下命令生成文件mstore.s：
```
    linux> gcc -Og -S mstore.c
mstore.s的完整内容如下：
    .file    "010-mstore.c"
    .text
    .globl   multstore
    .type    multstore, @function
multstore:
    pushq    %rbx
    movq     %rdx, %rbx
```






计算机内部的存储结构：
寄存器的本质就是存储空间
![](附件/Pasted%20image%2020251006135558.png)
