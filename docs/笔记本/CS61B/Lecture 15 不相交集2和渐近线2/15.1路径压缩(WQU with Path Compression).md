## What We have achieved?
|    Implementation    | Constructor | connect | isConnected |
| :------------------: | ----------- | ------- | ----------- |
|     ListOfSetsDS     | Θ(N)        | Θ(N)    | Θ(N)        |
| WeightedQuickUnionDS | Θ(N)        | O(logN) | O(logN)     |

 - 原始的办法最坏的情况需要耗时N+MN，首先构造函数要耗时N次。其次，每次连接函数以及判断函数都要耗时N次，总共操作M次，因此最坏的情况需要耗时N+2MN，省略常数项后答案为O(N)。
 - 同理WeightQuickUnionDS最坏的情况耗时N+2MlogN
 - 但是还有更好的办法，名为Weighted Quick Union with Path Compression.

---

## 下面来介绍Weight Quick Union with Path Compression

每执行一次isconnect，就要把所观测到的没有直接跟树根相连的元素直接连到树根上去，如此一来进行多次isconnect操作是有可能把每一个元素都直接跟树根相连的。
- 比如图一进行一次isconnect(15,10)操作之后就能变成图二，二者本质是没有区别的：
![](../Lecture15%20photo/Pasted%20image%2020250915223546.png)
Path compression results in a union/connected operations that are very very close to amortized constant time (amortized constant means “constant on average”).
路径压缩导致联合/连接操作非常非常接近平摊常数时间（平摊常数意味着“平均常数”）

In CS170, you’ll show that each isConnected or connect operation takes on average lg* N time because the tree is kept so compressed.
- lg*: How many times you need to press the log2 button on a calculator before you get to a number that is 1 or less. Example: [点击此处可细看](http://joshh.ug/logstar/demo.html)
- lg* is less than or equal to 5 for any realistic input.
- M operations on N nodes is O(N + M lg* N) - you will see this in CS170.
- PS：lg * N（也写作 lg* N 或 log* N）是**迭代对数函数**（iterated logarithm），在算法分析中常用来表示极慢增长的函数。这个函数的定义是：==对一个正整数 N，lg* N 表示对 N 连续取对数（通常是以 2 为底），直到结果 ≤ 1，总共需要多少次。==

|             Implementation              |  Runtime  |
| :-------------------------------------: | :-------: |
|              ListOfSetsDS               |  O(M N)   |
|               QuickFindDS               |  Θ(M N)   |
|              QuickUnionDS               |  O(M N)   |
|          WeightedQuickUnionDS           | O(M logN) |
| WeightedQuickUnionDSWithPathCompression | O(M α(N)) |
α(N)即为lg*N