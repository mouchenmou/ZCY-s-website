# 关于哈希算法的深度层解析
## Visualization for Some Basic Cases
![](附件/Pasted%20image%2020251005225813.png)

---

## Why Custom Hash Functions？
![](附件/Pasted%20image%2020251005230107.png)

---

## Contains
### 下面这段代码的意义是，只要两个数的数字相等的话，不管他们是不是同一种颜色，他们都是等价的。然后在这段代码的基础上，我们继续进行下面的一系列操作：
```java
    public boolean equals(Object o){
        if(o instanceof ColoredNumber otherCn){
            return this.sum == otherCn.num;
        }
        return false;
    }
```

### 通过下面这段代码建立一个包含0~19的哈希表，表格如下图所示：
```java
    int N = 20;
    HashSet<ColoredNumber> hs = new HashSet<>();
    for (int i = 0; i < N; i += 1){
        hs.add(new ColoredNumber(i));
    }
```
![](附件/Pasted%20image%2020251005231117.png)

### 接下来我们通过下面的代码再建立一个新的12，但是不把它放进表盘里，然后判断这个12是不是在表盘中。
```java
    ColoredNumber twelve = new ColoredNumber(12);
    hs.contains(twelve); //returns true
```
!!! tips
    此12非彼12，hs.contains(twelve)中的12是新建的12，不是原本就有的12，它们俩颜色不一样。
### 答案是只有$1/6$的概率会return true
### 原因如下：由于hs.contain()这个函数判断一个目标是否存在于哈希表中时，会先根据这个目标的哈希值进入特定的箱子中，然后再根据这个目标的真实值来判断这个目标是否存在于这个箱子中。由于此处的哈希值就是这个数的地址，那么我们假设新建的12的地址是6000，于是hs.contains()函数会进入编号为0的箱子中，然后判断这个箱子中有没有一个数字为12，然而此处的编号为0的箱子中只有2和19而没有12，因此这种情况下会return false。在这种情况下只有新建的12的地址除以6恰好为1时才会return true。
### 这个例子告诉我们，即使默认的hashcode能够很好的做到给每个箱子平均分配目标元素，我们还是要创建自定义的hash函数的原因。
### Basic rule：If two objects are equal, they'd better have the same hashCode so the hash table can find it.

---

## Duplicate Values
### 接着上面的模块，还有一道加深理解的题目
![](附件/Pasted%20image%2020251005232859.png)
![](附件/Pasted%20image%2020251005233023.png)