# 堆
## 堆的定义
我们把二叉最小堆定义为一个 **完整的二叉树**，它遵循 **最小堆属性**。
### 完整二叉树的定义：
一棵高度为h的二叉树：

1. 前h-1层都是满的（每一层的节点数都达到最大）
2. 第h层（最后一层）的节点从左到右连续排列，中间不能有空缺。

### 最小堆属性：
每个节点都小于或等于它的两个子节点

### 完整性：
如果一棵树只缺少底层的元素那么所有节点都尽可能往左靠

---

## 在堆中添加元素
![](附件/Pasted%20image%2020251006000445.png)
首先我们要保证完整二叉树的性质，如果添加在右边的6或者3下面的话，就不符合“中间不能有空缺”这一性质。因此不管插入多大的元素，都得先插在8旁边。然后，由于5大于3，因此需要将3一节一节往上移动，最终结果如下图所示：
![](附件/Pasted%20image%2020251006000650.png)
如果我们还想再插入一个5进来，那有该怎么操作呢？
首先为了确保“中间不能有空缺”，还是一样的，不管什么元素都得插到6的左边，但因为5比6小，所以5要跟6交换位置，最终结果如下图所示：
![](附件/Pasted%20image%2020251006000832.png)

---

## 在堆中删除元素
继续引用上图，如果我们要删除最小值的话应该怎么做呢？
首先，最小二叉堆的最小值绝对是树根，所以我们应该删除的元素就是树根，但是 **为了保证完整二叉树的性质，我们只能拿最下面那层最右边的元素去顶替树根**，然后再一步步改进。

1. 首先，我们要是把1删除了，那么6便成为树根。
2. 接着我们得考虑6的走向，到底是往左走还是往右走。
    - 如果我们往左走，那么3会跟6替换位置并成为新的树根
    - 但是3比1大，所以6往左走之后3还会跟1进行替换
    - 因此我们往右走
3. 让6往右逐步与1和5交换位置，最终结果如下图所示：
![](附件/Pasted%20image%2020251006002628.png)
如果我们还想继续删除树根，那么就得让5来成为新的树根。但是此处操作非常简便，往左走还是往右走都能一步到位，因此都可行，slide选择往左走，因此最终结果如下：
![](附件/Pasted%20image%2020251006003021.png)

---

## 递归表示（Recursive Representation）
下面是一种递归表示，它要求我们写出 parent (k) 这个函数的表达式
![](附件/Pasted%20image%2020251006003230.png)
首先我们需要了解swim的意图是什么。

- 它的意思是如果父节点的key比子节点的key大的话，就要交换这两个节点。
    - 比如说这幅图中 v>p，那么就要将v和p的位置交换。
- 现在要求我们写一段很简短的代码来实现swim这个函数。
    - 此处swim的意思是上浮，也就是往上走。
- 我们为什么要在swim中嵌套swim？
    - 是因为仅仅交换一次并不能完成所有的任务。
    - 就像这幅图中m<p，那么m和p交换完之后还得跟v交换。
- 因为swim是一层一层往上走的，所以我们需要返回的是父节点。

下面是老师给出的代码：
```java
    public int parent(int k){
        return (k-1)/2;
    }
```
!!! tips
    因为java比较特殊，它的int类型会舍去所有小数点。即5/2 = 2，因此使用这种方式能精准的返回父节点。庆幸的是c语言中，int也是直接省略小数点的，因此c也可以用这种方式进行递归。

但是cs61b书本中的实现方式不是这样的。它不在key数组的第0位填入任何东西，相当于浪费了一个额外的空间，使得父节点和子节点间的计算变得非常方便：
![](附件/Pasted%20image%2020251006004907.png)

---
## Priority Queue Summary
![](附件/Pasted%20image%2020251006004949.png)
