# 下面是c语言实现BST插入的全过程
```c
#include <stdio.h>
#include <stdlib.h>

// 定义二叉搜索树的节点结构
typedef struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
} TreeNode;

// 创建新节点
TreeNode* createNode(int val) {
    TreeNode* node = (TreeNode*)malloc(sizeof(TreeNode));
    node->val = val;
    node->left = node->right = NULL;
    return node;
}

// 插入函数
TreeNode* insert(TreeNode* root, int val) {
    if (root == NULL) {
        // 找到空位置，插入节点
        return createNode(val);
    }
    if (val < root->val) {
        root->left = insert(root->left, val);  // 插入到左子树
    } else if (val > root->val) {
        root->right = insert(root->right, val); // 插入到右子树
    } 
    return root;
}

// 中序遍历（可以验证 BST 是否结构正确）
void inorder(TreeNode* root) {
    if (root == NULL) {
        return;
    }
    inorder(root->left);
    printf("%d ", root->val);
    inorder(root->right);
}

int main() {
    TreeNode* root = NULL;
    int nums[] = {5, 3, 8, 1, 4, 7, 9};
    int n = sizeof(nums) / sizeof(nums[0]);
    for (int i = 0; i < n; i++) {
        root = insert(root, nums[i]);
    }
    printf("中序遍历结果：");
    inorder(root);  // 应该输出有序的：1 3 4 5 7 8 9
    printf("\n");
    return 0;
}
```