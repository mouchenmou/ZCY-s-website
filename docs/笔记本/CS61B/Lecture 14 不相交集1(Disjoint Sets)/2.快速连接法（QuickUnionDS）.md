![](../Lecture14%20photos/Pasted image 20250914144427.png)
## Hard Question：我们怎样才能把两个集合合并成一个集合并且只需要改变一个值？

## Answer：为每个项分配一个父项，而不是id，形成一个树状结构。
![](../Lecture14%20photos/Pasted image 20250914145345.png)

## 想要把3和2连接起来用两种做法：
1.把3接到2下面，延长第一棵树的右边的树枝，也就是把数组的3号地址中的值从-1改为2
2.给0再添加一条新的树枝，也就是把数组的3号地址中的值从-1改为0
- 第一种做法的缺点：如果一根树枝太长了，就会花费大量时间去寻找树枝之下的数值
- 第二种做法的缺点：如果枝条太多了，就要花费大量时间去寻找每根树枝下的数值
- PS：树根的值设为-1

## The Worst Case
If we always connect the first item's tree below the second item's tree, we can end up with a tree of height of height M after M operations：相当于是一棵树就那么一条树枝一直延长下去

## For N items, what is the worst case runtimes?
- For connect(p, q)?  Θ(N)
- For isconnect(p, q)? Θ(N)
![](../Lecture14%20photos/Pasted image 20250914152957.png)

| Implementation         | Constructor | connect | isConnected |
| ---------------------- | ----------- | ------- | ----------- |
| ListOfSetDS            | Θ(N)        | Θ(N)    | O(N)        |
| QuickFindDS（快速查找不相交集法） | Θ(N)        | Θ(N)    | Θ(1)        |
| QuickUnionDS（快速连接法）    | Θ(N)        | O(N)    | O(N)        |

## QuickFindDS连接需要Θ(N)时间。

## QuickUnionDS可能会使树长得很高。如果树不平衡，可能会导致比QuickFind更差的性能。

## 在最坏的情况下QuickUnionDS的connect以及isconnect都是Θ(N)，因此二者都是O(N)

## Observation: Things would be fine if we just kept our tree balanced.
