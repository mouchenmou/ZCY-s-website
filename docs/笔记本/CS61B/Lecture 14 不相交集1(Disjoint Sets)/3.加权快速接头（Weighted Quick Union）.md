## 1.准则：当我们将两棵树连接在一起时，应该始终将较小的树连接到较大的树下面。
![](../Lecture14%20photos/Pasted image 20250914164126.png)
根据我们的准则，可以判定要选A选项

---

## 2.Possible Approach
One possible approach is to keep track of the height of every tree.(跟踪每棵树的高度)
- Link up shorter tree below the larger tree.
- In case of a tie, break tie arbitrarily.(就像系领带，可以随意打破领带)
Unfortunately, tracking tree height is kind of annoying.
Interestingly, tracking the tree's size, a.k.a. "weight" works just as well asymptotically(跟踪树的”大小“，也就是”权重“，同样也是渐进的)
- 大小和重量都表示该树中的项目总数。
![](../Lecture14%20photos/Pasted image 20250914165237.png)

---

## 3.Implementing WeightedQuickUnion
Minimal changes needed:
- Use parent[] array as before.
- isConnected ( int p, int q ) requires no changes.
- connect ( int p, int q) needs to somehow keep track of sizes.
	- See the [old Disjoint Sets lab]([https://sp19.datastructur.es/materials/lab/lab6/lab6](https://sp19.datastructur.es/materials/lab/lab6/lab6)"点击此处查看详情")
	- Two common approaches:
		- Replace -1 with -weight for roots (top approach).
		- Create a separate size array (bottom approach).

![](../Lecture14%20photos/Pasted image 20250914170417.png)
- 在上图中，parent数组中的索引存放的值为负数的话代表这个索引是个树根，即，0，1，2，3，4，6都是树根。负号后面的数值表示的是这棵树所含的元素个数。
- 在这组数组中，如果要连接0和6的话应该把0连接到6上面，因为0只包含了两个元素但是6包含了4个元素。

---


## 4.Weighted Quick Union Performance
![](../Lecture14%20photos/Pasted image 20250914183749.png)

---

## 5.Performance Summary
![](../Lecture14%20photos/Pasted image 20250914183857.png)
QuickUnion's runtimes are O(H)，and weightedQuickUnionDS height is given by H=O(logN), therefore connect and isConnect are both O(logN).
通过调整quickuniond，我们实现了对数时间性能。快到足以解决所有实际问题。
因为isconnect的最坏情况是O(log N)，然而isconnect是由connect构建出来的，因此connect的最坏情况也是O(log N)。

---

## 一个小疑问：
有人问到加权重量查找是把元素少的树接到元素多的树下面，这种情况下connect和isConnect的时间都是O(logN)。但是有人会提问，为什么不把高度更矮的树接到高度更高的树下面去。当然这样也是可以的，并且这种方式的connect和isConnect也都是O(logN)，这里不予证明。



