## Case1: What would Python display? If you get stuck, try it out in the Python interpreter!"
```python    
    >>> def ab(c, d):
            if c > 5:
               print(c)
            elif c > 7:
                print(d)
            print('foo')
    >>> ab(10, 20)
```  
### 输出结果：
```python
    10
    foo
```
### 原因：
这个例子考察了 `if-elif` 结构的执行顺序：
1. **`if c > 5:`**: 由于传入的 `c` 是 `10`，条件 `10 > 5` 为真（True）。
    - 执行 `print(c)`，打印出 **`10`**。
        
2. **`elif c > 7:`**: **关键点：** `elif`（else if）只有在前面的 `if` 条件为假时才会去检查。
    - 虽然 `10 > 7` 确实是真的，但因为前面的 `if` 已经执行过了，Python 会直接跳过整个 `elif` 块。所以 `20` 永远不会被打印。
3. **`print('foo')`**: 这个语句的缩进与 `if/elif` 对齐，这意味着它在条件判断结构之外。
    - 无论前面的判断结果如何，只要函数被调用，这行代码都会执行。所以打印出 **`foo`**。

---

## Case2:  What would Python display? If you get stuck, try it out in the Python interpreter!
```python
    >>> def bake(cake, make):
        if cake == 0:
            cake = cake + 1
            print(cake)
        if cake == 1:
             print(make)
        else:
            return cake
        return make
    >>> bake(1, "mashed potatoes")
```

### 输出结果：
```python
    1
    chocolate
    'chocolate'
```

### 原因
### 1. `print(make)` —— 打印（输出内容）

当调用 `print("mashed potatoes")` 时：

- Python 认为你想把这个信息展示给最终用户。
- 它会剥离掉字符串的外壳（引号），只展示字符串的 **具体内容**。
- **现象**：没有引号。

### 2. `return make` —— 返回（对象表示）

在 Python **交互式解释器**（即带 `>>>` 的界面）中，如果你运行一个函数：

- 解释器会自动捕捉函数的 **返回值**。
- 为了让你看清这个返回值的“数据类型”，它会调用内置的 `repr()` 函数来展示这个对象。
- 对于字符串，它会带上引号，告诉你：“嘿，这是一个 **字符串类型** 的对象，不是一个变量名。”
- **现象**：带有引号。
