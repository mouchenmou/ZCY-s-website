## 疑难1：

```Python
    >>> b = lambda x, y: lambda: x + y # Lambdas can return other lambdas! 
    >>> c = b(8, 4) 
    
    >>> c
    >>> c()

```

### 第一步：`c = b(8, 4)`

当执行 `c = b(8, 4)` 时：
1. 调用外层的 lambda 函数，将 `x` 绑定为 `8`，`y` 绑定为 `4`。
2. 它返回了一个内层的 lambda 函数：`lambda: x + y`。
3. 此时，`c` 指向了这个内层函数，且由于闭包机制，它“记住”了 `x=8, y=4`。

### 第二步：第一处输出 `>>> c`

**输出结果：**

```
    <function <lambda> at 0x...>
```

- **原因**：`c` 现在是一个函数对象。在 Python 交互式界面中直接输入变量名，它会显示该对象的描述（Representation）。因为 `c` 是一个匿名函数（lambda），所以它显示为 `<function <lambda> ...>`。
- **注意**：此时并没有执行加法，只是告诉你在 `c` 这个位置有一个函数。

### 第三步：第二处输出 `>>> c()`

**输出结果：**
```
    12
```
- **原因**：括号 `()` 代表调用。当执行 `c()` 时，才真正运行了内层函数的内容 `x + y`。
- **过程**：它取回了闭包里保存的 `8` 和 `4`，计算 $8 + 4$，得到结果 `12`。

---
